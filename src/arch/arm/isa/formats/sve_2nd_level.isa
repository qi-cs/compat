// Copyright (c) 2017-2020, 2025 ARM Limited
// All rights reserved
//
// The license below extends only to copyright in the software and shall
// not be construed as granting a license to any other intellectual
// property including but not limited to intellectual property relating
// to a hardware implementation of the functionality of the software
// licensed hereunder.  You may use the software subject to the license
// terms below provided that you ensure that this notice is replicated
// unmodified and in its entirety in all distributions of the software,
// modified or unmodified, in source code or in binary form.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/// @file
/// SVE 2nd-level decoder.

output decoder {{
namespace Aarch64
{
    inline void
    decodeSveImmElemSize(uint8_t tsize, uint8_t* esize, uint8_t *size)
    {
        *size = findMsbSet(tsize);
        *esize = 8 << *size;
    }

    inline unsigned
    decodeSveImmRightShiftAmt(uint8_t tsize, uint8_t esize, uint8_t imm)
    {
        return 2 * esize - ((tsize << 3) | imm);
    }

    inline unsigned
    decodeSveImmLeftShiftAmt(uint8_t tsize, uint8_t esize, uint8_t imm)
    {
        return ((tsize << 3) | imm) - esize;
    }

    // C4.1.36.1 SVE integer add/subtract vectors (predicated)
    StaticInstPtr
    decodeSveIntAddSubVecPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 18, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=000
            return decodeSveBinDestrPredU<SveAddPred>(
                    size, machInst, zdn, zm, pg);
          case 0x1:   // opc=001
            return decodeSveBinDestrPredU<SveSubPred>(
                    size, machInst, zdn, zm, pg);
          case 0x3:   // opc=011
            return decodeSveBinDestrPredU<SveSubr>(
                    size, machInst, zdn, zm, pg);
          case 0x4:   // opc=100
            if (size == 0x3) {
                // ADDPT
                return new Unknown64(machInst);
            }
            break;
          case 0x5:   // opc=101
            if (size == 0x3) {
                // SUBPT
                return new Unknown64(machInst);
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveIntAddSubVecPred

    // C4.1.36.2 SVE integer min/max/difference (predicated)
    StaticInstPtr
    decodeSveIntMinMaxDiffPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t u = bits(machInst, 16);
        uint8_t opc = bits(machInst, 18, 17);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=00
            return decodeSveBinDestrPred<SveSmax, SveUmax>(
                    size, u, machInst, zdn, zm, pg);
          case 0x1:   // opc=01
            return decodeSveBinDestrPred<SveSmin, SveUmin>(
                    size, u, machInst, zdn, zm, pg);
          case 0x2:   // opc=10
            return decodeSveBinDestrPred<SveSabd, SveUabd>(
                    size, u, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMinMaxDiffPred

    // C4.1.36.3 SVE integer multiply vectors (predicated)
    StaticInstPtr
    decodeSveIntMulVecPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t u = bits(machInst, 16);
        uint8_t h = bits(machInst, 17);
        uint8_t size = bits(machInst, 23, 22);

        switch (h) {
          case 0x0:   // H=0
            if (u == 0) {
                return decodeSveBinDestrPredU<SveMul>(
                        size, machInst, zdn, zm, pg);
            }
            break;
          case 0x1:   // H=1
            return decodeSveBinDestrPred<SveSmulh, SveUmulh>(
                    size, u, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMulVecPred

    // C4.1.36.4 SVE integer divide vectors (predicated)
    StaticInstPtr
    decodeSveIntDivVecPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t u = bits(machInst, 16);
        uint8_t r = bits(machInst, 17);
        uint8_t size = bits(machInst, 23, 22);

        switch (r) {
          case 0x0:   // r=0
            if (size == 0x2 || size == 0x3) {
                return decodeSveBinDestrPred<SveSdiv, SveUdiv>(
                        size, u, machInst, zdn, zm, pg);
            }
            break;
          case 0x1:   // r=1
            if (size == 0x2 || size == 0x3) {
                return decodeSveBinDestrPred<SveSdivr, SveUdivr>(
                        size, u, machInst, zdn, zm, pg);
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveIntDivVecPred

    // C4.1.36.5 SVE bitwise logical operations (predicated)
    StaticInstPtr
    decodeSveBitLogOpPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 18, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=000
            return decodeSveBinDestrPredU<SveOrrPred>(
                    size, machInst, zdn, zm, pg);
          case 0x1:   // opc=001
            return decodeSveBinDestrPredU<SveEorPred>(
                    size, machInst, zdn, zm, pg);
          case 0x2:   // opc=010
            return decodeSveBinDestrPredU<SveAndPred>(
                    size, machInst, zdn, zm, pg);
          case 0x3:   // opc=011
            return decodeSveBinDestrPredU<SveBicPred>(
                    size, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitLogOpPred

    // C4.1.36 SVE Integer Binary Arithmetic - Predicated
    StaticInstPtr
    decodeSveIntBinArithPred(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 20, 18);
        switch (op0) {
          case 0x0: case 0x1:   // op0=00x
            return decodeSveIntAddSubVecPred(machInst);
          case 0x2: case 0x3:   // op0=01x
            return decodeSveIntMinMaxDiffPred(machInst);
          case 0x4:             // op0=100
            return decodeSveIntMulVecPred(machInst);
          case 0x5:             // op0=101
            return decodeSveIntDivVecPred(machInst);
          case 0x6: case 0x7:   // op0=11x
            return decodeSveBitLogOpPred(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntBinArithPred

    // C4.1.37.1 SVE integer add reduction (predicated)
    StaticInstPtr
    decodeSveIntAddReducPred(ExtMachInst machInst)
    {
        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t u = bits(machInst, 16);
        uint8_t op = bits(machInst, 17);
        uint8_t size = bits(machInst, 23, 22);

        if (op == 0x0) {
            return decodeSveWideningReduc<SveSaddv, SveUaddv>(
                    size, u, machInst, vd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntAddReducPred

    // C4.1.37.2 SVE integer add reduction (quadwords)
    StaticInstPtr
    decodeSveIntAddReducQuad(ExtMachInst machInst)
    {
        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t op_u = bits(machInst, 17, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (op_u == 0x1) {  // op=0 U=1
            return decodeSveUnaryPredU<SveAddqv>(size, machInst, vd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntAddReducQuad

    // C4.1.37.3 SVE integer min/max reduction (predicated)
    StaticInstPtr
    decodeSveIntMinMaxReducPred(ExtMachInst machInst)
    {
        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t u = bits(machInst, 16);
        uint8_t op = bits(machInst, 17);
        uint8_t size = bits(machInst, 23, 22);

        switch (op) {
          case 0x0:   // op=0
            return decodeSveUnaryPred<SveSmaxv, SveUmaxv>(
                    size, u, machInst, vd, zn, pg);
          case 0x1:   // op=1
            return decodeSveUnaryPred<SveSminv, SveUminv>(
                    size, u, machInst, vd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMinMaxReducPred

    // C4.1.37.4 SVE integer min/max reduction (quadwords)
    StaticInstPtr
    decodeSveIntMinMaxReducQuad(ExtMachInst machInst)
    {
        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t u = bits(machInst, 16);
        uint8_t op = bits(machInst, 17);
        uint8_t size = bits(machInst, 23, 22);

        switch (op) {
          case 0x0:   // op=0
            return decodeSveUnaryPred<SveSmaxqv, SveUmaxqv>(
                    size, u, machInst, vd, zn, pg);
          case 0x1:   // op=1
            return decodeSveUnaryPred<SveSminqv, SveUminqv>(
                    size, u, machInst, vd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMinMaxReducQuad

    // C4.1.37.5 SVE constructive prefix (predicated)
    StaticInstPtr
    decodeSveConstrPrefixPred(ExtMachInst machInst)
    {
        uint8_t opc = bits(machInst, 18, 17);
        if (opc != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t merge = bits(machInst, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (merge) {
            return decodeSveUnaryPredU<SveMovprfxPredM>(
                    size, machInst, zd, zn, pg);
        } else {
            return decodeSveUnaryPredU<SveMovprfxPredZ>(
                    size, machInst, zd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveConstrPrefixPred

    // C4.1.37.6 SVE bitwise logical reduction (predicated)
    StaticInstPtr
    decodeSveBitLogReducPred(ExtMachInst machInst)
    {
        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 17, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=00
            return decodeSveUnaryPredU<SveOrv>(size, machInst, vd, zn, pg);
          case 0x1:   // opc=01
            return decodeSveUnaryPredU<SveEorv>(size, machInst, vd, zn, pg);
          case 0x2:   // opc=10
            return decodeSveUnaryPredU<SveAndv>(size, machInst, vd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitLogReducPred

    // C4.1.37.7 SVE bitwise logical reduction (quadwords)
    StaticInstPtr
    decodeSveBitLogReducQuad(ExtMachInst machInst)
    {
        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 17, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=00
            return decodeSveUnaryPredU<SveOrqv>(size, machInst, vd, zn, pg);
          case 0x1:   // opc=01
            return decodeSveUnaryPredU<SveEorqv>(size, machInst, vd, zn, pg);
          case 0x2:   // opc=10
            return decodeSveUnaryPredU<SveAndqv>(size, machInst, vd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitLogReducQuad

    // C4.1.37 SVE Integer Reduction
    StaticInstPtr
    decodeSveIntReduc(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 20, 18);
        switch (op0) {
          case 0x0:             // op0=000
            return decodeSveIntAddReducPred(machInst);
          case 0x1:             // op0=001
            return decodeSveIntAddReducQuad(machInst);
          case 0x2:             // op0=010
            return decodeSveIntMinMaxReducPred(machInst);
          case 0x3:             // op0=011
            return decodeSveIntMinMaxReducQuad(machInst);
          case 0x4: case 0x5:   // op0=10x
            return decodeSveConstrPrefixPred(machInst);
          case 0x6:             // op0=110
            return decodeSveBitLogReducPred(machInst);
          case 0x7:             // op0=111
            return decodeSveBitLogReducQuad(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntReduc

    // C4.1.38.1 SVE bitwise shift by immediate (predicated)
    StaticInstPtr
    decodeSveBitShiftByImmPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t imm3 = (uint8_t) bits(machInst, 7, 5);
        uint8_t l = bits(machInst, 17);
        uint8_t opc_l_u = bits(machInst, 19, 16);
        uint8_t tsize = (bits(machInst, 23, 22) << 2) | bits(machInst, 9, 8);

        uint8_t esize = 0;
        uint8_t size = 0;
        if (tsize == 0x0) {
            return new Unknown64(machInst);
        } else {
            decodeSveImmElemSize(tsize, &esize, &size);
        }

        unsigned shiftAmt = 0;
        if (l == 0) {
            shiftAmt = decodeSveImmRightShiftAmt(tsize, esize, imm3);
        } else {
            shiftAmt = decodeSveImmLeftShiftAmt(tsize, esize, imm3);
        }

        switch (opc_l_u) {
          case 0x0:   // opc=00 L=0 U=0
            return decodeSveBinImmPredU<SveAsrImmPred>(
                    size, machInst, zdn, shiftAmt, pg);
          case 0x1:   // opc=00 L=0 U=1
            return decodeSveBinImmPredU<SveLsrImmPred>(
                    size, machInst, zdn, shiftAmt, pg);
          case 0x3:   // opc=00 L=1 U=1
            return decodeSveBinImmPredU<SveLslImmPred>(
                    size, machInst, zdn, shiftAmt, pg);
          case 0x4:   // opc=01 L=0 U=0
            return decodeSveBinImmPredS<SveAsrd>(
                    size, machInst, zdn, shiftAmt, pg);
          case 0x6:   // opc=01 L=1 U=0
            return decodeSveBinImmPredS<SveSqshlImm>(
                    size, machInst, zdn, shiftAmt, pg);
          case 0x7:   // opc=01 L=1 U=1
            return decodeSveBinImmPredU<SveUqshlImm>(
                    size, machInst, zdn, shiftAmt, pg);
          case 0xc:   // opc=11 L=0 U=0
            return decodeSveBinImmPredS<SveSrshr>(
                    size, machInst, zdn, shiftAmt, pg);
          case 0xd:   // opc=11 L=0 U=1
            return decodeSveBinImmPredU<SveUrshr>(
                    size, machInst, zdn, shiftAmt, pg);
          case 0xf:   // opc=11 L=1 U=1
            return decodeSveBinImmPredS<SveSqshlu>(
                    size, machInst, zdn, shiftAmt, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitShiftByImmPred

    // C4.1.38.2 SVE bitwise shift by vector (predicated)
    StaticInstPtr
    decodeSveBitShiftByVecPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t r_l_u = bits(machInst, 18, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (r_l_u) {
          case 0x0:   // R=0 L=0 U=0
            return decodeSveBinDestrPredU<SveAsrPred>(
                    size, machInst, zdn, zm, pg);
          case 0x1:   // R=0 L=0 U=1
            return decodeSveBinDestrPredU<SveLsrPred>(
                    size, machInst, zdn, zm, pg);
          case 0x3:   // R=0 L=1 U=1
            return decodeSveBinDestrPredU<SveLslPred>(
                    size, machInst, zdn, zm, pg);
          case 0x4:   // R=1 L=0 U=0
            return decodeSveBinDestrPredU<SveAsrr>(
                    size, machInst, zdn, zm, pg);
          case 0x5:   // R=1 L=0 U=1
            return decodeSveBinDestrPredU<SveLsrr>(
                    size, machInst, zdn, zm, pg);
          case 0x7:   // R=1 L=1 U=1
            return decodeSveBinDestrPredU<SveLslr>(
                    size, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitShiftByVecPred

    // C4.1.38.3 SVE bitwise shift by wide elements (predicated)
    StaticInstPtr
    decodeSveBitShiftByWideElemPred(ExtMachInst machInst)
    {
        uint8_t r = bits(machInst, 18);
        if (r != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t l_u = bits(machInst, 17, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (l_u) {
          case 0x0:   // R=0 L=0 U=0
            return decodeSveBinDestrPredU<SveAsrWidePred>(
                    size, machInst, zdn, zm, pg);
          case 0x1:   // R=0 L=0 U=1
            return decodeSveBinDestrPredU<SveLsrWidePred>(
                    size, machInst, zdn, zm, pg);
          case 0x3:   // R=0 L=1 U=1
            return decodeSveBinDestrPredU<SveLslWidePred>(
                    size, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitShiftByWideElemPred

    // C4.1.38 SVE Bitwise Shift - Predicated
    StaticInstPtr
    decodeSveBitwiseShiftPred(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 20, 19);
        switch (op0)
        {
          case 0x0: case 0x1:   // op0=0x
            return decodeSveBitShiftByImmPred(machInst);
          case 0x2:             // op0=10
            return decodeSveBitShiftByVecPred(machInst);
          case 0x3:             // op0=11
            return decodeSveBitShiftByWideElemPred(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitwiseShiftPred

    // C4.1.39.1 SVE integer unary operations (predicated)
    StaticInstPtr
    decodeSveIntUnaryOpPred(ExtMachInst machInst)
    {
        uint8_t m = bits(machInst, 20);
        if (m != 0x1) {
            return new Unknown64(machInst);
        }

        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 18, 16);
        unsigned esize = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // M=1 opc=000
            if (esize == 0) break;
            return decodeSveUnaryExtendFromBPredU<SveSxtb>(
                    esize, machInst, zd, zn, pg);
          case 0x1:   // M=1 opc=001
            if (esize == 0) break;
            return decodeSveUnaryExtendFromBPredU<SveUxtb>(
                    esize, machInst, zd, zn, pg);
          case 0x2:   // M=1 opc=010
            if (esize < 2) break;
            return decodeSveUnaryExtendFromHPredU<SveSxth>(
                    esize, machInst, zd, zn, pg);
          case 0x3:   // M=1 opc=011
            if (esize < 2) break;
            return decodeSveUnaryExtendFromHPredU<SveUxth>(
                    esize, machInst, zd, zn, pg);
          case 0x4:   // M=1 opc=100
            if (esize != 3) break;
            return new SveSxtw<uint32_t, uint64_t>(machInst, zd, zn, pg);
          case 0x5:   // M=1 opc=101
            if (esize != 3) break;
            return new SveUxtw<uint32_t, uint64_t>(machInst, zd, zn, pg);
          case 0x6:   // M=1 opc=110
            return decodeSveUnaryPredS<SveAbs>(esize, machInst, zd, zn, pg);
          case 0x7:   // M=1 opc=111
            return decodeSveUnaryPredS<SveNeg>(esize, machInst, zd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntUnaryOpPred

    // C4.1.39.2 SVE bitwise unary operations (predicated)
    StaticInstPtr
    decodeSveBitUnaryOpPred(ExtMachInst machInst)
    {
        uint8_t m = bits(machInst, 20);
        if (m != 0x1) {
            return new Unknown64(machInst);
        }

        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 18, 16);
        unsigned esize = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // M=1 opc=000
            return decodeSveUnaryPredS<SveCls>(esize, machInst, zd, zn, pg);
          case 0x1:   // M=1 opc=001
            return decodeSveUnaryPredS<SveClz>(esize, machInst, zd, zn, pg);
          case 0x2:   // M=1 opc=010
            return decodeSveUnaryPredU<SveCnt>(esize, machInst, zd, zn, pg);
          case 0x3:   // M=1 opc=011
            return decodeSveUnaryPredU<SveCnot>(esize, machInst, zd, zn, pg);
          case 0x4:   // M=1 opc=100
            return decodeSveUnaryPredF<SveFabs>(esize, machInst, zd, zn, pg);
          case 0x5:   // M=1 opc=101
            return decodeSveUnaryPredF<SveFneg>(esize, machInst, zd, zn, pg);
          case 0x6:   // M=1 opc=110
            return decodeSveUnaryPredU<SveNot>(esize, machInst, zd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitUnaryOpPred

    // C4.1.39 SVE Integer Unary Arithmetic - Predicated
    StaticInstPtr
    decodeSveIntUnaryArithPred(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 20, 19);
        switch (op0) {
          case 0x0: case 0x2:   // op0=x0
            return decodeSveIntUnaryOpPred(machInst);
          case 0x1: case 0x3:   // op0=x1
            return decodeSveBitUnaryOpPred(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntUnaryArithPred

    // C4.1.40.1 SVE integer multiply-accumulate writing addend (predicated)
    StaticInstPtr
    decodeSveIntMulAddWrAddendPred(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t op = bits(machInst, 13);
        uint8_t size = bits(machInst, 23, 22);

        switch (op) {
          case 0x0:   // op=0
            return decodeSveTerPredS<SveMla>(size, machInst, zda, zn, zm, pg);
          case 0x1:   // op=1
            return decodeSveTerPredS<SveMls>(size, machInst, zda, zn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMulAddWrAddendPred

    // C4.1.40.2 SVE integer multiply-add writing multiplicand (predicated)
    StaticInstPtr
    decodeSveIntMulAddWrMultiplicandPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex za = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t op = bits(machInst, 13);
        uint8_t size = bits(machInst, 23, 22);

        switch (op) {
          case 0x0:   // op=0
            return decodeSveTerPredS<SveMad>(size, machInst, zdn, za, zm, pg);
          case 0x1:   // op=1
            return decodeSveTerPredS<SveMsb>(size, machInst, zdn, za, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMulAddWrMultiplicandPred

    // C4.1.40 SVE Integer Multiply-Add - Predicated
    StaticInstPtr
    decodeSveIntMulAddPred(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 15);
        switch (op0) {
          case 0x0:
            return decodeSveIntMulAddWrAddendPred(machInst);
          case 0x1:
            return decodeSveIntMulAddWrMultiplicandPred(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMulAddPred

    // C4.1.41.1 SVE bitwise logical operations (unpredicated)
    StaticInstPtr
    decodeSveBitLogOpUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t opc = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=00
            return new SveAndUnpred<uint64_t>(machInst, zd, zn, zm);
          case 0x1:   // opc=01
            return new SveOrrUnpred<uint64_t>(machInst, zd, zn, zm);
          case 0x2:   // opc=10
            return new SveEorUnpred<uint64_t>(machInst, zd, zn, zm);
          case 0x3:   // opc=11
            return new SveBicUnpred<uint64_t>(machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitLogOpUnpred

    // C4.1.41.2 SVE2 bitwise ternary operations
    StaticInstPtr
    decodeSve2BitTernaryOp(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zk = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t opc_o2 = bits(machInst, 23, 22) << 1 | bits(machInst, 10);

        switch (opc_o2) {
          case 0x0:   // opc=00 o2=0
            return new SveEor3<uint64_t>(machInst, zdn, zm, zk);
          case 0x1:   // opc=00 o2=1
            return new SveBsl<uint64_t>(machInst, zdn, zm, zk);
          case 0x2:   // opc=01 o2=0
            return new SveBcax<uint64_t>(machInst, zdn, zm, zk);
          case 0x3:   // opc=01 o2=1
            return new SveBsl1n<uint64_t>(machInst, zdn, zm, zk);
          case 0x5:   // opc=10 o2=1
            return new SveBsl2n<uint64_t>(machInst, zdn, zm, zk);
          case 0x7:   // opc=11 o2=1
            return new SveNbsl<uint64_t>(machInst, zdn, zm, zk);
        }
        return new Unknown64(machInst);
    }  // decodeSve2BitTernaryOp

    // XAR
    StaticInstPtr
    decodeSveXarInst(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t imm3 = (RegIndex) (uint8_t) bits(machInst, 18, 16);
        uint8_t tsize = (bits(machInst, 23, 22) << 2) | bits(machInst, 20, 19);

        uint8_t esize = 0;
        uint8_t size = 0;
        if (tsize == 0x0) {
            return new Unknown64(machInst);
        } else {
            decodeSveImmElemSize(tsize, &esize, &size);
        }

        unsigned rot_am = decodeSveImmRightShiftAmt(tsize, esize, imm3);
        return decodeSveBinImmUnpredU<SveXar>(size, machInst, zdn, zm, rot_am);
    }  // decodeSveXarInst

    // C4.1.41 SVE Bitwise Logical - Unpredicated
    StaticInstPtr
    decodeSveBitwiseLogUnpred(ExtMachInst machInst)
    {
        uint8_t opc = bits(machInst, 12, 10);
        switch (opc) {
          case 0x4:             // opc=100
            return decodeSveBitLogOpUnpred(machInst);
          case 0x5:             // opc=101
            // XAR
            return decodeSveXarInst(machInst);
          case 0x6: case 0x7:   // 11x
            return decodeSve2BitTernaryOp(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitwiseLogUnpred

    // C4.1.42 SVE Index Generation
    StaticInstPtr
    decodeSveIndexGen(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint8_t op0 = bits(machInst, 11, 10);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (op0) {
          case 0x0:   // op0=00
            { // INDEX (immediate)
                int8_t imm5 = sext<5>(bits(machInst, 9, 5));
                int8_t imm5b = sext<5>(bits(machInst, 20, 16));
                switch (size) {
                  case 0:
                    return new SveIndexII<int8_t>(machInst, zd, imm5, imm5b);
                  case 1:
                    return new SveIndexII<int16_t>(machInst, zd, imm5, imm5b);
                  case 2:
                    return new SveIndexII<int32_t>(machInst, zd, imm5, imm5b);
                  case 3:
                    return new SveIndexII<int64_t>(machInst, zd, imm5, imm5b);
                }
                break;
            }
          case 0x1:   // op0=01
            { // INDEX (scalar, immediate)
                int8_t imm5 = sext<5>(bits(machInst, 20, 16));
                RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
                switch (size) {
                  case 0:
                    return new SveIndexRI<int8_t>(machInst, zd, zn, imm5);
                  case 1:
                    return new SveIndexRI<int16_t>(machInst, zd, zn, imm5);
                  case 2:
                    return new SveIndexRI<int32_t>(machInst, zd, zn, imm5);
                  case 3:
                    return new SveIndexRI<int64_t>(machInst, zd, zn, imm5);
                }
                break;
            }
          case 0x2:   // op0=10
            { // INDEX (immediate, scalar)
                int8_t imm5 = sext<5>(bits(machInst, 9, 5));
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
                switch (size) {
                  case 0:
                    return new SveIndexIR<int8_t>(machInst, zd, imm5, zm);
                  case 1:
                    return new SveIndexIR<int16_t>(machInst, zd, imm5, zm);
                  case 2:
                    return new SveIndexIR<int32_t>(machInst, zd, imm5, zm);
                  case 3:
                    return new SveIndexIR<int64_t>(machInst, zd, imm5, zm);
                }
                break;
            }
          case 0x3:   // op0=11
            { // INDEX (scalars)
                RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
                switch (size) {
                  case 0:
                    return new SveIndexRR<int8_t>(machInst, zd, zn, zm);
                  case 1:
                    return new SveIndexRR<int16_t>(machInst, zd, zn, zm);
                  case 2:
                    return new SveIndexRR<int32_t>(machInst, zd, zn, zm);
                  case 3:
                    return new SveIndexRR<int64_t>(machInst, zd, zn, zm);
                }
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveIndexGen

    // C4.1.43.1 SVE stack frame adjustment
    StaticInstPtr
    decodeSveStackFrameAdjustment(ExtMachInst machInst)
    {
        RegIndex rd = makeSP((RegIndex) (uint8_t) bits(machInst, 4, 0));
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 20, 16));
        uint64_t imm = sext<6>(bits(machInst, 10, 5));
        uint8_t op = bits(machInst, 22);

        if (op == 0x0) {
            return new AddvlXImm(machInst, rd, rn, imm);
        } else {
            return new AddplXImm(machInst, rd, rn, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSveStackFrameAdjustment

    // C4.1.43.2 Streaming SVE stack frame adjustment
    StaticInstPtr
    decodeSmeStackFrameAdjustment(ExtMachInst machInst)
    {
        RegIndex rd = makeSP((RegIndex) (uint8_t) bits(machInst, 4, 0));
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 20, 16));
        uint64_t imm = sext<6>(bits(machInst, 10, 5));
        uint8_t op = bits(machInst, 22);

        if (op == 0x0) {
            return new SmeAddsvl(machInst, rd, rn, imm);
        } else {
            return new SmeAddspl(machInst, rd, rn, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSmeStackFrameAdjustment

    // C4.1.43.3 SVE stack frame size
    StaticInstPtr
    decodeSveStackFrameSize(ExtMachInst machInst)
    {
        RegIndex rd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint64_t imm = sext<6>(bits(machInst, 10, 5));
        uint8_t op_opc2 = (bits(machInst, 22) << 5) | bits(machInst, 20, 16);

        if (op_opc2 == 0x1f) {    // op=0 opc2=11111
            return new SveRdvl(machInst, rd, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSveStackFrameSize

    // C4.1.43.4 Streaming SVE stack frame size
    StaticInstPtr
    decodeSmeStackFrameSize(ExtMachInst machInst)
    {
        RegIndex rd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint64_t imm = sext<6>(bits(machInst, 10, 5));
        uint8_t op_opc2 = (bits(machInst, 22) << 5) | bits(machInst, 20, 16);

        if (op_opc2 == 0x1f) {    // op=0 opc2=11111
            return new SmeRdsvl(machInst, rd, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSmeStackFrameSize

    // C4.1.43 SVE Stack Allocation
    StaticInstPtr
    decodeSveStackAlloc(ExtMachInst machInst)
    {
        uint8_t op0_op1 = (bits(machInst, 23) << 1) | bits(machInst, 11);
        switch (op0_op1) {
          case 0x0:   // op0=0 op1=0
            return decodeSveStackFrameAdjustment(machInst);
          case 0x1:   // op0=0 op1=1
            return decodeSmeStackFrameAdjustment(machInst);
          case 0x2:   // op0=1 op1=0
            return decodeSveStackFrameSize(machInst);
          case 0x3:   // op0=1 op1=1
            return decodeSmeStackFrameSize(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveStackAlloc

    // C4.1.44.1 SVE2 integer multiply vectors (unpredicated)
    StaticInstPtr
    decodeSve2IntMulVecUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t opc = bits(machInst, 11, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=00
            return decodeSveBinUnpredU<SveMulUnpred>(
                    size, machInst, zd, zn, zm);
          case 0x1:   // opc=01
            if (size == 0x0) {  // size=00 opc=01
                return new SvePmul<uint8_t>(machInst, zd, zn, zm);
            }
            break;
          case 0x2:   // opc=10
            return decodeSveBinUnpredS<SveSmulhUnpred>(
                    size, machInst, zd, zn, zm);
          case 0x3:   // opc=11
            return decodeSveBinUnpredU<SveUmulhUnpred>(
                    size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntMulVecUnpred

    // C4.1.44.2 SVE2 signed saturating doubling multiply high (unpredicated)
    StaticInstPtr
    decodeSve2SignSatDoubleMulHighUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t r = bits(machInst, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (r) {
          case 0x0:   // r=0
            return decodeSveBinUnpredS<SveSqdmulh>(size, machInst, zd, zn, zm);
          case 0x1:   // r=1
            return decodeSveBinUnpredS<SveSqrdmulh>(
                    size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2SignSatDoubleMulHighUnpred

    // C4.1.44 SVE2 Integer Multiply - Unpredicated
    StaticInstPtr
    decodeSve2IntMulUnpred(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 12, 11);
        switch (op0) {
          case 0x0: case 0x1: // op0=0x
            return decodeSve2IntMulVecUnpred(machInst);
          case 0x2:           // op0=10
            return decodeSve2SignSatDoubleMulHighUnpred(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntMulUnpred

    // C4.1.45.1 SVE bitwise shift by wide elements (unpredicated)
    StaticInstPtr
    decodeSveBitShiftByWideElemUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t opc = (uint8_t) bits(machInst, 11, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=00
            return decodeSveBinUnpredU<SveAsrWideUnpred>(
                    size, machInst, zd, zn, zm);
          case 0x1:   // opc=01
            return decodeSveBinUnpredU<SveLsrWideUnpred>(
                    size, machInst, zd, zn, zm);
          case 0x3:   // opc=11
            return decodeSveBinUnpredU<SveLslWideUnpred>(
                    size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitShiftByWideElemUnpred

    // C4.1.45.2 SVE bitwise shift by immediate (unpredicated)
    StaticInstPtr
    decodeSveBitShiftByImmUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t opc = bits(machInst, 11, 10);
        uint8_t imm3 = (uint8_t) bits(machInst, 18, 16);
        uint8_t tsize = (bits(machInst, 23, 22) << 2) | bits(machInst, 20, 19);

        uint8_t esize = 0;
        uint8_t size = 0;
        if (tsize == 0x0) {
            return new Unknown64(machInst);
        } else {
            decodeSveImmElemSize(tsize, &esize, &size);
        }

        unsigned shiftAmt = 0;
        if (bits(opc, 1) == 0) {
            shiftAmt = decodeSveImmRightShiftAmt(tsize, esize, imm3);
        } else {
            shiftAmt = decodeSveImmLeftShiftAmt(tsize, esize, imm3);
        }

        switch (opc) {
          case 0x00:    // opc=00
            return decodeSveBinImmUnpredU<SveAsrImmUnpred>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x01:    // opc=01
            return decodeSveBinImmUnpredU<SveLsrImmUnpred>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x03:    // opc=11
            return decodeSveBinImmUnpredU<SveLslImmUnpred>(
                    size, machInst, zd, zn, shiftAmt);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitShiftByImmUnpred

    // C4.1.45 SVE Bitwise Shift - Unpredicated
    StaticInstPtr
    decodeSveBitwiseShiftUnpred(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 12);
        switch (op0) {
          case 0x0:   // op0=0
            return decodeSveBitShiftByWideElemUnpred(machInst);
          case 0x1:   // op0=1
            return decodeSveBitShiftByImmUnpred(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveBitwiseShiftUnpred

    // C4.1.46 SVE Integer Misc - Unpredicated
    StaticInstPtr
    decodeSveIntMiscUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t op0 = bits(machInst, 11, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (op0) {
          case 0x0:   // op0=0x op=0
            // SVE floating-point trig select coefficient
            {
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
                return decodeSveBinUnpredF<SveFtssel>(
                        size, machInst, zd, zn, zm);
            }
          case 0x2:   // op0=10
            // SVE floating-point exponential accelerator
            {
                uint8_t opc = bits(machInst, 20, 16);
                if (opc == 0) {
                    return decodeSveUnaryUnpredF<SveFexpa>(
                            size, machInst, zd, zn);
                }
                break;
            }
          case 0x3:   // op0=11
            // SVE constructive prefix (unpredicated)
            {
                uint8_t opc2 = bits(machInst, 20, 16);
                if (size == 0x0 && opc2 == 0x0) {
                    return new SveMovprfxUnpred<uint64_t>(machInst, zd, zn);
                }
                break;
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMiscUnpred

    // C4.1.47.1 SVE saturating inc/dec vector by element count
    StaticInstPtr
    decodeSveSatIncDecVecByElemCnt(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint8_t pattern = (uint8_t) bits(machInst, 9, 5);
        uint8_t imm4 = (uint8_t) bits(machInst, 19, 16) + 1;
        uint8_t d_u = bits(machInst, 11, 10);
        unsigned size = (unsigned) bits(machInst, 23, 22);

        switch (d_u) {
          case 0x0:   // D=0 U=0
            return decodeSveElemIntCountLS<SveSqincv>(size,
                    machInst, zdn, pattern, imm4);
          case 0x1:   // D=0 U=1
            return decodeSveElemIntCountLU<SveUqincv>(size,
                    machInst, zdn, pattern, imm4);
          case 0x2:   // D=1 U=0
            return decodeSveElemIntCountLS<SveSqdecv>(size,
                    machInst, zdn, pattern, imm4);
          case 0x3:   // D=1 U=1
            return decodeSveElemIntCountLU<SveUqdecv>(size,
                    machInst, zdn, pattern, imm4);
        }
        return new Unknown64(machInst);
    }  // decodeSveSatIncDecVecByElemCnt

    // C4.1.47.2 SVE element count
    StaticInstPtr
    decodeSveElemCntSub(ExtMachInst machInst)
    {
        uint8_t op = bits(machInst, 10);
        if (op != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex rd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint8_t pattern = (uint8_t) bits(machInst, 9, 5);
        uint8_t imm4 = (uint8_t) bits(machInst, 19, 16) + 1;
        unsigned size = (unsigned) bits(machInst, 23, 22);

        return decodeSveElemIntCountU<SveCntx>(
                size, machInst, rd, pattern, imm4);
    }  // decodeSveElemCntSub

    // C4.1.47.3 SVE inc/dec vector by element count
    StaticInstPtr
    decodeSveIncDecVecByElemCnt(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint8_t pattern = (uint8_t) bits(machInst, 9, 5);
        uint8_t d = bits(machInst, 10);
        uint8_t imm4 = (uint8_t) bits(machInst, 19, 16) + 1;
        unsigned size = (unsigned) bits(machInst, 23, 22);

        switch (d) {
          case 0x0:   // D=0
            return decodeSveElemIntCountLU<SveIncv>(size,
                    machInst, zdn, pattern, imm4);
          case 0x1:   // D=1
            return decodeSveElemIntCountLU<SveDecv>(size,
                    machInst, zdn, pattern, imm4);
        }
        return new Unknown64(machInst);
    }  // decodeSveIncDecVecByElemCnt

    // C4.1.47.4 SVE inc/dec register by element count
    StaticInstPtr
    decodeSveIncDecRegByElemCnt(ExtMachInst machInst)
    {
        RegIndex rdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint8_t pattern = (uint8_t) bits(machInst, 9, 5);
        uint8_t d = bits(machInst, 10);
        uint8_t imm4 = (uint8_t) bits(machInst, 19, 16) + 1;
        unsigned size = (unsigned) bits(machInst, 23, 22);

        switch (d) {
          case 0x0:   // D=0
            return decodeSveElemIntCountU<SveInc>(size, machInst,
                    rdn, pattern, imm4);
          case 0x1:   // D=1
            return decodeSveElemIntCountU<SveDec>(size, machInst,
                    rdn, pattern, imm4);
        }
        return new Unknown64(machInst);
    }  // decodeSveIncDecRegByElemCnt

    // C4.1.47.5 SVE saturating inc/dec register by element count
    StaticInstPtr
    decodeSveSatIncDecRegByElemCnt(ExtMachInst machInst)
    {
        RegIndex rdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint8_t pattern = (uint8_t) bits(machInst, 9, 5);
        uint8_t sf_d_u = (bits(machInst, 20) << 2) | bits(machInst, 11, 10);
        uint8_t imm4 = (uint8_t) bits(machInst, 19, 16) + 1;
        unsigned size = (unsigned) bits(machInst, 23, 22);

        switch (sf_d_u) {
          case 0x0:   // sf=0 D=0 U=0
            return decodeSveElemIntCountS<SveSqinc32>(size,
                    machInst, rdn, pattern, imm4);
          case 0x1:   // sf=0 D=0 U=1
            return decodeSveElemIntCountU<SveUqinc32>(size,
                    machInst, rdn, pattern, imm4);
          case 0x2:   // sf=0 D=1 U=0
            return decodeSveElemIntCountS<SveSqdec32>(size,
                    machInst, rdn, pattern, imm4);
          case 0x3:   // sf=0 D=1 U=1
            return decodeSveElemIntCountU<SveUqdec32>(size,
                    machInst, rdn, pattern, imm4);
          case 0x4:   // sf=1 D=0 U=0
            return decodeSveElemIntCountS<SveSqinc>(size,
                    machInst, rdn, pattern, imm4);
          case 0x5:   // sf=1 D=0 U=1
            return decodeSveElemIntCountU<SveUqinc>(size,
                    machInst, rdn, pattern, imm4);
          case 0x6:   // sf=1 D=1 U=0
            return decodeSveElemIntCountS<SveSqdec>(size,
                    machInst, rdn, pattern, imm4);
          case 0x7:   // sf=1 D=1 U=1
            return decodeSveElemIntCountU<SveUqdec>(size,
                    machInst, rdn, pattern, imm4);
        }
        return new Unknown64(machInst);
    }  // decodeSveSatIncDecRegByElemCnt

    // C4.1.47 SVE Element Count
    StaticInstPtr
    decodeSveElemCount(ExtMachInst machInst)
    {
        uint8_t op0_op1 = bits(machInst, 20) << 3 | bits(machInst, 13, 11);
        switch (op0_op1) {
          case 0x0: case 0x1:                       // op0=0 op1=00x
            return decodeSveSatIncDecVecByElemCnt(machInst);
          case 0x4:                                 // op0=0 op1=100
            return decodeSveElemCntSub(machInst);
          case 0x8:                                 // op0=1 op1=000
            return decodeSveIncDecVecByElemCnt(machInst);
          case 0xc:                                 // op0=1 op1=100
            return decodeSveIncDecRegByElemCnt(machInst);
          case 0x6: case 0x7: case 0xe: case 0xf:   // op0=x op1=11x
            return decodeSveSatIncDecRegByElemCnt(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveElemCount

    // C4.1.48 SVE Permute Vector - Extract
    StaticInstPtr
    decodeSvePermVecExtract(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0); // zd
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);  // zn
        uint8_t position =
            bits(machInst, 20, 16) << 3 | bits(machInst, 12, 10);
        uint8_t op0 = bits(machInst, 22);

        if (op0 == 1) {
            // Constructive
            return new SveExt<uint8_t>(
                    machInst, zdn, zm, (zm + 1) % 32, position);
        } else {
            // Destructive
            return new SveExt<uint8_t>(machInst, zdn, zdn, zm, position);
        }
        return new Unknown64(machInst);
    }  // decodeSvePermVecExtract

    // C4.1.49 SVE Permute Vector - Segments
    StaticInstPtr
    decodeSvePermVecSeg(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);

        uint8_t opc_h = bits(machInst, 12, 10);
        switch (opc_h) {
          case 0x0:   // opc=00 H=0
            return new SveZip1Q<__uint128_t>(machInst, zd, zn, zm);
          case 0x1:   // opc=00 H=1
            return new SveZip2Q<__uint128_t>(machInst, zd, zn, zm);
          case 0x2:   // opc=01 H=0
            return new SveUzp1Q<__uint128_t>(machInst, zd, zn, zm);
          case 0x3:   // opc=01 H=1
            return new SveUzp2Q<__uint128_t>(machInst, zd, zn, zm);
          case 0x6:   // opc=11 H=0
            return new SveTrn1Q<__uint128_t>(machInst, zd, zn, zm);
          case 0x7:   // opc=11 H=1
            return new SveTrn2Q<__uint128_t>(machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSvePermVecSeg

    // C4.1.50 SVE Bitwise Immediate
    StaticInstPtr
    decodeSveBitwiseImm(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        bool n = bits(machInst, 17);
        uint8_t immr = bits(machInst, 16, 11);
        uint8_t imms = bits(machInst, 10, 5);

        // Decode bitmask
        // len = MSB(n:NOT(imms)), len < 1 is undefined
        uint8_t len = 0;
        if (n) {
            len = 6;
        } else if (imms == 0x3f || imms == 0x3e) {
            return new Unknown64(machInst);
        } else {
            len = findMsbSet(imms ^ 0x3f);
        }
        // Generate r, s, and size
        uint64_t r = bits(immr, len - 1, 0);
        uint64_t s = bits(imms, len - 1, 0);
        uint8_t size = 1 << len;
        if (s == size - 1)
            return new Unknown64(machInst);
        // Generate the pattern with s 1s, rotated by r, with size bits
        uint64_t pattern = mask(s + 1);
        if (r) {
            pattern = (pattern >> r) | (pattern << (size - r));
            pattern &= mask(size);
        }
        // Replicate that to fill up the immediate
        for (unsigned i = 1; i < (64 / size); i *= 2)
            pattern |= (pattern << (i * size));
        uint64_t imm = pattern;

        if (bits(machInst, 19, 18) == 0x0) {
            if (bits(machInst, 23, 22) == 0x3) {
                return new SveDupm<uint64_t>(machInst, zd, imm);
            } else {
                switch (bits(machInst, 23, 22)) {
                  case 0x0:
                    return new SveOrrImm<uint64_t>(machInst, zd, imm);
                  case 0x1:
                    return new SveEorImm<uint64_t>(machInst, zd, imm);
                  case 0x2:
                    return new SveAndImm<uint64_t>(machInst, zd, imm);
                }
            }
        }

        return new Unknown64(machInst);
    }  // decodeSveBitwiseImm

    // C4.1.51 SVE Integer Wide Immediate - Predicated
    StaticInstPtr
    decodeSveIntWideImmPred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 19, 16);
        uint8_t op0 = bits(machInst, 15, 13);
        uint8_t size = bits(machInst, 23, 22);

        if (bits(op0, 2) == 0x0) {  // op0=0xx
            // SVE copy integer immediate (predicated)
            uint64_t imm = bits(machInst, 12, 5);
            uint8_t sh = bits(machInst, 13);
            uint8_t m = bits(machInst, 14);
            if (sh) {
                if (size == 0x0) {
                    return new Unknown64(machInst);
                }
                imm <<= 8;
            }
            if (m) {
                if (sh) {
                    return decodeSveWideImmPredU<SveCpyImmMerge>(
                        size, machInst, zd, sext<16>(imm), pg);
                } else {
                    return decodeSveWideImmPredU<SveCpyImmMerge>(
                        size, machInst, zd, sext<8>(imm), pg);
                }
            } else {
                if (sh) {
                    return decodeSveWideImmPredU<SveCpyImmZero>(
                        size, machInst, zd, sext<16>(imm), pg,
                        false /* isMerging */);
                } else {
                    return decodeSveWideImmPredU<SveCpyImmZero>(
                        size, machInst, zd, sext<8>(imm), pg,
                        false /* isMerging */);
                }
            }
        } else if (op0 == 0x6 && size != 0x0) { // op0=110
            // FCPY
            uint64_t imm = vfp_modified_imm(bits(machInst, 12, 5),
                decode_fp_data_type(size));
            return decodeSveWideImmPredF<SveFcpy>(size, machInst, zd, imm, pg);
        }

        return new Unknown64(machInst);
    }  // decodeSveIntWideImmPred

    // C4.1.52 SVE Permute Vector - One Source Quadwords
    StaticInstPtr
    decodeSvePermVecOneSrcQuad(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 23, 22);
        uint8_t op1 = bits(machInst, 20);
        if (op0 == 0x0) {   // op0=00
            // DUPQ
            RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            uint8_t imm = (uint8_t) bits(machInst, 20, 16);

            if (imm & 0x1) {
                imm >>= 1;
                return new SveDupqIdx<uint8_t>(machInst, zd, zn, imm);
            } else if (imm & 0x2) {
                imm >>= 2;
                return new SveDupqIdx<uint16_t>(machInst, zd, zn, imm);
            } else if (imm & 0x4) {
                imm >>= 3;
                return new SveDupqIdx<uint32_t>(machInst, zd, zn, imm);
            } else if (imm & 0x8) {
                imm >>= 4;
                return new SveDupqIdx<uint64_t>(machInst, zd, zn, imm);
            }
        } else if (op0 == 0x1 && op1 == 0) {  // op0=01 op1=0
            // EXTQ
            uint8_t position = bits(machInst, 20, 16);
            RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
            return new SveExtq<uint8_t>(machInst, zdn, zdn, zm, position);
        }
        return new Unknown64(machInst);
    }  // decodeSvePermVecOneSrcQuad

    // C4.1.53.1 SVE move predicate from vector
    StaticInstPtr
    decodeSveMovPredFromVec(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t opc_opc2 = (bits(machInst, 23, 22) << 2) |
                            bits(machInst, 18, 17);

        if ((opc_opc2 & 0xf) == 0x1) {
            uint8_t imm = 0;
            return new SvePmovPred<uint8_t>(machInst, pd, zn, imm);
        } else if ((opc_opc2 & 0xe) == 0x2) {
            uint8_t imm = bits(machInst, 17);
            return new SvePmovPred<uint16_t>(machInst, pd, zn, imm);
        } else if ((opc_opc2 & 0xc) == 0x4) {
            uint8_t imm = bits(machInst, 18, 17);
            return new SvePmovPred<uint32_t>(machInst, pd, zn, imm);
        } else if ((opc_opc2 & 0x8) == 0x8) {
            uint8_t imm = (bits(machInst, 22) << 2) | bits(machInst, 18, 17);
            return new SvePmovPred<uint64_t>(machInst, pd, zn, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSveMovPredFromVec

    // C4.1.53.2 SVE move predicate into vector
    StaticInstPtr
    decodeSveMovPredIntoVec(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
        uint8_t opc_opc2 = (bits(machInst, 23, 22) << 2) |
                            bits(machInst, 18, 17);

        if ((opc_opc2 & 0xf) == 0x1) {
            uint8_t imm = 0;
            return new SvePmovVec<uint8_t>(machInst, zd, pn, imm);
        } else if ((opc_opc2 & 0xe) == 0x2) {
            uint8_t imm = bits(machInst, 17);
            return new SvePmovVec<uint16_t>(machInst, zd, pn, imm);
        } else if ((opc_opc2 & 0xc) == 0x4) {
            uint8_t imm = bits(machInst, 18, 17);
            return new SvePmovVec<uint32_t>(machInst, zd, pn, imm);
        } else if ((opc_opc2 & 0x8) == 0x8) {
            uint8_t imm = (bits(machInst, 22) << 2) | bits(machInst, 18, 17);
            return new SvePmovVec<uint64_t>(machInst, zd, pn, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSveMovPredIntoVec

    // C4.1.53.3 SVE unpack vector elements
    StaticInstPtr
    decodeSveUnpackVecElem(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t u_h = bits(machInst, 17, 16);
        unsigned size = (unsigned) bits(machInst, 23, 22);

        switch (u_h) {
          case 0x0:   // U=0 H=0
            return decodeSveUnpackS<SveSunpklo>(size, machInst, zd, zn);
          case 0x1:   // U=0 H=1
            return decodeSveUnpackS<SveSunpkhi>(size, machInst, zd, zn);
          case 0x2:   // U=1 H=0
            return decodeSveUnpackU<SveUunpklo>(size, machInst, zd, zn);
          case 0x3:   // U=1 H=1
            return decodeSveUnpackU<SveUunpkhi>(size, machInst, zd, zn);
        }
        return new Unknown64(machInst);
    }  // decodeSveUnpackVecElem

    // C4.1.53 SVE Permute Vector - Unpredicated
    StaticInstPtr
    decodeSvePermVecUnpred(ExtMachInst machInst)
    {
        uint8_t op0_op1 = bits(machInst, 20, 16);
        switch (op0_op1) {
          case 0x00: // op0=00, op1=000
            // DUP (scalar)
            {
                uint8_t size = bits(machInst, 23, 22);
                RegIndex rn = makeSP(
                        (RegIndex) (uint8_t) bits(machInst, 9, 5));
                RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                return decodeSveUnaryUnpredU<SveDupScalar>(
                        size, machInst, zd, rn);
            }
          case 0x04: // op0=00, op1=100
            // INSR (scalar)
            {
                uint8_t size = bits(machInst, 23, 22);
                RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
                return decodeSveUnaryUnpredU<SveInsr>(size, machInst, zdn, rm);
            }
          case 0x08: case 0x0a: case 0x0c: case 0x0e: // op0=01, op1=xx0
            {
                uint8_t op3 = bits(machInst, 4);
                if (op3 == 0) {
                    return decodeSveMovPredFromVec(machInst);
                }
                break;
            }
          case 0x09: case 0x0b: case 0x0d: case 0x0f: // op0=01, op1=xx1
            {
                uint8_t op2 = bits(machInst, 9);
                if (op2 == 0) {
                    return decodeSveMovPredIntoVec(machInst);
                }
                break;
            }
          case 0x10: case 0x11: case 0x12: case 0x13: // op0=10, op1=0xx
            return decodeSveUnpackVecElem(machInst);
          case 0x14: // op0=10, op1=100
            // INSR (SIMD&FP scalar)
            {
                uint8_t size = bits(machInst, 23, 22);
                RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex vm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
                return decodeSveUnaryUnpredU<SveInsrf>(
                    size, machInst, zdn, vm);
            }
          case 0x18: // op0=11, op1=000
            // REV (vector)
            {
                uint8_t size = bits(machInst, 23, 22);
                RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
                return decodeSveUnaryUnpredU<SveRevv>(size, machInst, zd, zn);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSvePermVecUnpred

    // C4.1.54.1 SVE unpack predicate elements
    StaticInstPtr
    decodeSveUnpackPredElem(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
        uint8_t h = bits(machInst, 16);

        if (h) {
            return new SvePunpkhi<uint8_t, uint16_t>(machInst, pd, pn);
        } else {
            return new SvePunpklo<uint8_t, uint16_t>(machInst, pd, pn);
        }
        return new Unknown64(machInst);
    }  // decodeSveUnpackPredElem

    // C4.1.54.2 SVE permute predicate elements
    StaticInstPtr
    decodeSvePremPredElem(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t opc_h = bits(machInst, 12, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc_h) {
          case 0x0:   // opc=00 H=0
            return decodeSveBinUnpredU<SveZip1Pred>(size,
                    machInst, zd, zn, zm);
          case 0x1:   // opc=00 H=1
            return decodeSveBinUnpredU<SveZip2Pred>(size,
                    machInst, zd, zn, zm);
          case 0x2:   // opc=01 H=0
            return decodeSveBinUnpredU<SveUzp1Pred>(size,
                    machInst, zd, zn, zm);
          case 0x3:   // opc=01 H=1
            return decodeSveBinUnpredU<SveUzp2Pred>(size,
                    machInst, zd, zn, zm);
          case 0x4:   // opc=10 H=0
            return decodeSveBinUnpredU<SveTrn1Pred>(size,
                    machInst, zd, zn, zm);
          case 0x5:   // opc=10 H=1
            return decodeSveBinUnpredU<SveTrn2Pred>(size,
                    machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSvePremPredElem

    // C4.1.54 SVE Permute Predicate
    StaticInstPtr
    decodeSvePermPredicates(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 23, 22);
        uint8_t op1 = bits(machInst, 20, 16);
        uint8_t op2 = bits(machInst, 12, 9);
        uint8_t op3 = bits(machInst, 4);

        if (bits(op1, 4) == 0x0 && bits(op2, 0) == 0x0 && op3 == 0x0) {
            // op1=0xxxx op2=xxx0, op3=0
            return decodeSvePremPredElem(machInst);
        } else if (op0 == 0x0 && bits(op1, 4, 1) == 0x8 && !op2 && !op3) {
            // op0=00 op1=1000x op2=0000 op3=0
            return decodeSveUnpackPredElem(machInst);
        } else if (op1 == 0x14 && op2 == 0x0 && op3 == 0) {
            // op1=10100 op2=0000 op3=0
            // REV (predicate)
            uint8_t size = bits(machInst, 23, 22);
            RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
            RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
            return decodeSveUnaryUnpredU<SveRevp>(size, machInst, pd, pn);
        }
        return new Unknown64(machInst);
    }  // decodeSvePermPredicates

    // C4.1.55.1 SVE compress active elements
    StaticInstPtr
    decodeSveCompressActiveElem(ExtMachInst machInst)
    {
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        RegIndex zn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
        RegIndex zd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        uint8_t size = bits(machInst, 23, 22);

        switch (size) {
          case 0x2:
            return new SveCompact<uint32_t>(machInst, zd, zn, pg);
          case 0x3:
            return new SveCompact<uint64_t>(machInst, zd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveCompressActiveElem

    // C4.1.55.2 SVE extract element to general register
    StaticInstPtr
    decodeSveExtElemToGenReg(ExtMachInst machInst)
    {
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        RegIndex zn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
        RegIndex rd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        uint8_t AB = bits(machInst, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (!AB) {
            return decodeSveUnaryPredU<SveLasta>(size, machInst, rd, zn, pg);
        } else {
            return decodeSveUnaryPredU<SveLastb>(size, machInst, rd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveExtElemToGenReg

    // C4.1.55.3 SVE extract element to SIMD&FP scalar register
    StaticInstPtr
    decodeSveExtElemToSimdScaReg(ExtMachInst machInst)
    {
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        RegIndex zn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
        RegIndex vd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        uint8_t AB = bits(machInst, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (!AB) {
            return decodeSveUnaryPredU<SveLastaf>(size, machInst, vd, zn, pg);
        } else {
            return decodeSveUnaryPredU<SveLastbf>(size, machInst, vd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveExtElemToSimdScaReg

    // C4.1.55.4 SVE reverse within elements
    StaticInstPtr
    decodeSveRevWithinElem(ExtMachInst machInst)
    {
        uint8_t z = bits(machInst, 13);
        if (z != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        RegIndex zn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
        RegIndex zd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        uint8_t opc = bits(machInst, 17, 16);
        unsigned size = (unsigned) bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=00 Z=0
            switch (size) {
              case 1:
                return new SveRevb<uint16_t>(machInst, zd, zn, pg);
              case 2:
                return new SveRevb<uint32_t>(machInst, zd, zn, pg);
              case 3:
                return new SveRevb<uint64_t>(machInst, zd, zn, pg);
            }
            break;
          case 0x1:   // opc=01 Z=0
            switch (size) {
              case 2:
                return new SveRevh<uint32_t>(machInst, zd, zn, pg);
              case 3:
                return new SveRevh<uint64_t>(machInst, zd, zn, pg);
            }
            break;
          case 0x2:   // opc=10 Z=0
            if (size == 3) {
                return new SveRevw<uint64_t>(machInst, zd, zn, pg);
            }
            break;
          case 0x3:   // opc=11 Z=0
            return decodeSveUnaryPredU<SveRbit>(size, machInst, zd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveRevWithinElem

    // C4.1.55.5 SVE conditionally broadcast element to vector
    StaticInstPtr
    decodeSveCondBroadElemToVec(ExtMachInst machInst)
    {
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        RegIndex zm = (RegIndex)(uint8_t) bits(machInst, 9, 5);
        RegIndex zdn = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        uint8_t AB = bits(machInst, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (!AB) {
            return decodeSveUnaryPredU<SveClastav>(size,
                    machInst, zdn, zm, pg);
        } else {
            return decodeSveUnaryPredU<SveClastbv>(size,
                    machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveCondBroadElemToVec

    // C4.1.55.6 SVE conditionally extract element to SIMD&FP scalar
    StaticInstPtr
    decodeSveCondExtElemToSimdSca(ExtMachInst machInst)
    {
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        RegIndex zm = (RegIndex)(uint8_t) bits(machInst, 9, 5);
        RegIndex zdn = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        uint8_t AB = bits(machInst, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (!AB) {
            return decodeSveUnaryPredU<SveClastaf>(size,
                    machInst, zdn, zm, pg);
        } else {
            return decodeSveUnaryPredU<SveClastbf>(size,
                    machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveCondExtElemToSimdSca

    // C4.1.55.7 SVE reverse doublewords
    StaticInstPtr
    decodeSveRevDoubleWord(ExtMachInst machInst)
    {
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        RegIndex zn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
        RegIndex zd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        uint8_t z = bits(machInst, 13);
        unsigned size = (unsigned) bits(machInst, 23, 22);

        if (size == 0x0 && z == 0) {
            return new SveRevd<__uint128_t>(machInst, zd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveRevDoubleWord

    // C4.1.55.8 SVE conditionally extract element to general register
    StaticInstPtr
    decodeSveCondExtElemToGenReg(ExtMachInst machInst)
    {
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        RegIndex zm = (RegIndex)(uint8_t) bits(machInst, 9, 5);
        RegIndex rdn = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        uint8_t AB = bits(machInst, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (!AB) {
            return decodeSveUnaryPredU<SveClasta>(size, machInst, rdn, zm, pg);
        } else {
            return decodeSveUnaryPredU<SveClastb>(size, machInst, rdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveCondExtElemToGenReg

    // C4.1.55 SVE Permute Vector - Predicated
    StaticInstPtr
    decodeSvePermVecPred(ExtMachInst machInst)
    {
        uint8_t op0_op1 = bits(machInst, 20, 17);
        switch (op0_op1) {
          case 0x0:             // op0=0 op1=000
            {
                uint8_t op2_op3 = (bits(machInst, 16) << 1) |
                                  bits(machInst, 13);
                if (op2_op3 == 0x0) {   // op0=0 op1=000 op2=0 op3=0
                    // CPY (SIMD&FP scalar)
                    RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                    RegIndex vn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
                    RegIndex zd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                    uint8_t size = bits(machInst, 23, 22);
                    return decodeSveUnaryPredU<SveCpySimdFpScalar>(size,
                            machInst, zd, vn, pg);
                } else if (op2_op3 == 0x2) { // op0=0 op1=000 op2=1 op3=0
                    return decodeSveCompressActiveElem(machInst);
                } else {  // op0=0 op1=000 op3=1
                    return decodeSveExtElemToGenReg(machInst);
                }
                break;
            }
          case 0x1:             // op0=0 op1=001
            {
                uint8_t op3 = bits(machInst, 13);
                if (op3 == 0) {  // op2=x, op3=0
                    return decodeSveExtElemToSimdScaReg(machInst);
                }
                break;
            }
          case 0x2: case 0x3:   // op0=0 op1=01x
            return decodeSveRevWithinElem(machInst);
          case 0x4:             // op0=0 op1=100
            {
                uint8_t op2 = bits(machInst, 16);
                uint8_t op3 = bits(machInst, 13);
                if (op2 == 0 && op3 == 1) {   // op0=0 op1=100 op2=0 op3=1
                    // CPY (scalar)
                    RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                    RegIndex rn = makeSP(
                            (RegIndex)(uint8_t) bits(machInst, 9, 5));
                    RegIndex zd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                    uint8_t size = bits(machInst, 23, 22);
                    return decodeSveUnaryPredU<SveCpyScalar>(size,
                            machInst, zd, rn, pg);
                } else if (op3 == 0) {        // op0=0 op1=100 op2=x op3=0
                    return decodeSveCondBroadElemToVec(machInst);
                }
                break;
            }
          case 0x5:             // op0=0 op1=101
            {
                uint8_t op3 = bits(machInst, 13);
                if (op3 == 0) { // op0=0 op1=101 op2=x op3=0
                    return decodeSveCondExtElemToSimdSca(machInst);
                }
                break;
            }
          case 0x6:             // op0=0 op1=110
            {
                uint8_t op2_op3 = (bits(machInst, 16) << 1) |
                                  bits(machInst, 13);
                if (op2_op3 == 0x0) {         // op0=0 op1=110 op2=0 op3=0
                    // SPLICE  Destructive
                    uint8_t size = bits(machInst, 23, 22);
                    RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                    RegIndex zdn = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                    RegIndex zm = (RegIndex)(uint8_t) bits(machInst, 9, 5);
                    return decodeSveBinConstrPredU<SveSpliceDestr>(
                            size, machInst, zdn, zdn, zm, pg,
                            SvePredType::SELECT);
                } else if (op2_op3 == 0x2) {  // op0=0 op1=110 op2=1 op3=0
                    // SPLICE  Constructive
                    uint8_t size = bits(machInst, 23, 22);
                    RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
                    RegIndex zd = (RegIndex)(uint8_t) bits(machInst, 4, 0);
                    RegIndex zn = (RegIndex)(uint8_t) bits(machInst, 9, 5);
                    return decodeSveBinConstrPredU<SveSpliceConst>(
                            size, machInst, zd, zn, (zn + 1) % 32, pg,
                            SvePredType::SELECT);
                }
                break;
            }
          case 0x7:             // op0=0 op1=111
            {
                uint8_t op2 = bits(machInst, 16);
                if(op2 == 0) { // op0=0 op1=111 op2=0
                    return decodeSveRevDoubleWord(machInst);
                }
                break;
            }
          case 0x8:             // op0=1 op1=000
            {
                uint8_t op3 = bits(machInst, 13);
                if (op3 == 1) {   // op0=1 op1=000 op2=x op3=1
                    return decodeSveCondExtElemToGenReg(machInst);
                }
                break;
            }
        }
        return new Unknown64(machInst);
    }  // decodeSvePermVecPred

    // C4.1.56.1 SVE integer compare vectors
    StaticInstPtr
    decodeSveIntCmpVecSub(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t)bits(machInst, 3, 0);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        RegIndex zn = (RegIndex) (uint8_t)bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t op_o2_ne = bits(machInst, 15) << 2 |
                            bits(machInst, 13) << 1 | bits(machInst, 4);

        switch (op_o2_ne) {
          case 0x0:   // op=0 o2=0 ne=0
            return decodeSveTerPredU<SveCmphs>(size,
                    machInst, pd, zn, zm, pg);
          case 0x1:   // op=0 o2=0 ne=1
            return decodeSveTerPredU<SveCmphi>(size,
                    machInst, pd, zn, zm, pg);
          case 0x2:   // op=0 o2=1 ne=0
            if (size != 3) {
                return decodeSveTerPredWS<SveCmpeqw>(size,
                        machInst, pd, zn, zm, pg);
            }
            break;
          case 0x3:   // op=0 o2=1 ne=1
            if (size != 3) {
                return decodeSveTerPredWS<SveCmpnew>(size,
                        machInst, pd, zn, zm, pg);
            }
            break;
          case 0x4:   // op=1 o2=0 ne=0
            return decodeSveTerPredS<SveCmpge>(size,
                    machInst, pd, zn, zm, pg);
          case 0x5:   // op=1 o2=0 ne=1
            return decodeSveTerPredS<SveCmpgt>(size,
                    machInst, pd, zn, zm, pg);
          case 0x6:   // op=1 o2=1 ne=0
            return decodeSveTerPredS<SveCmpeq>(size,
                    machInst, pd, zn, zm, pg);
          case 0x7:   // op=1 o2=1 ne=1
            return decodeSveTerPredS<SveCmpne>(size,
                    machInst, pd, zn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpVecSub

    // C4.1.56.2 SVE integer compare with wide elements
    StaticInstPtr
    decodeSveIntCmpWithWideElem(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t)bits(machInst, 3, 0);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        RegIndex zn = (RegIndex) (uint8_t)bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t op_o2_ne = bits(machInst, 15) << 2 |
                            bits(machInst, 13) << 1 | bits(machInst, 4);

        switch (op_o2_ne) {
          case 0:
            return decodeSveTerPredWS<SveCmpgew>(size,
                    machInst, pd, zn, zm, pg);
          case 1:
            return decodeSveTerPredWS<SveCmpgtw>(size,
                    machInst, pd, zn, zm, pg);
          case 2:
            return decodeSveTerPredWS<SveCmpltw>(size,
                    machInst, pd, zn, zm, pg);
          case 3:
            return decodeSveTerPredWS<SveCmplew>(size,
                    machInst, pd, zn, zm, pg);
          case 4:
            return decodeSveTerPredWU<SveCmphsw>(size,
                    machInst, pd, zn, zm, pg);
          case 5:
            return decodeSveTerPredWU<SveCmphiw>(size,
                    machInst, pd, zn, zm, pg);
          case 6:
            return decodeSveTerPredWU<SveCmplow>(size,
                    machInst, pd, zn, zm, pg);
          case 7:
            return decodeSveTerPredWU<SveCmplsw>(size,
                    machInst, pd, zn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpWithWideElem

    // C4.1.56 SVE Integer Compare - Vectors
    StaticInstPtr
    decodeSveIntCmpVec(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 14);
        switch (op0) {
          case 0x0:
            return decodeSveIntCmpVecSub(machInst);
          case 0x1:
            return decodeSveIntCmpWithWideElem(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpVec

    // C4.1.57 SVE Propagate Break
    StaticInstPtr
    decodeSvePropagateBreak(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 9);
        if (op0 != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex pm = (RegIndex)(uint8_t) bits(machInst, 19, 16);
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 13, 10);
        RegIndex pn = (RegIndex)(uint8_t) bits(machInst, 8, 5);
        RegIndex pd = (RegIndex)(uint8_t) bits(machInst, 3, 0);
        uint8_t op_s_b = (bits(machInst, 23, 22) << 1) | bits(machInst, 4);

        switch (op_s_b) {
          case 0x0:   // op=0 S=0 B=0
            return new SveBrkpa(machInst, pd, pn, pm, pg);
          case 0x1:   // op=0 S=0 B=1
            return new SveBrkpb(machInst, pd, pn, pm, pg);
          case 0x2:   // op=0 S=1 B=0
            return new SveBrkpas(machInst, pd, pn, pm, pg);
          case 0x3:   // op=0 S=1 B=1
            return new SveBrkpbs(machInst, pd, pn, pm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSvePropagateBreak

    // C4.1.58 SVE Partition Break
    StaticInstPtr
    decodeSvePartitionBreak(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 23);
        uint8_t op1 = bits(machInst, 19, 16);
        uint8_t op2 = bits(machInst, 9);
        uint8_t op3 = bits(machInst, 4);

        if (op0 == 0x0 && op1 == 0x8 && op2 == 0x0 && op3 == 0x0) {
            // op0=0 op1=1000 op2=0 op3=0
            // SVE propagate break to next partition
            RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 13, 10);
            RegIndex pn = (RegIndex)(uint8_t) bits(machInst, 8, 5);
            RegIndex pdm = (RegIndex)(uint8_t) bits(machInst, 3, 0);
            uint8_t s = bits(machInst, 22);
            if (s == 0x0) {
                return new SveBrkn(machInst, pdm, pn, pdm, pg);
            } else {
                return new SveBrkns(machInst, pdm, pn, pdm, pg);
            }
        } else if (op1 == 0x0 && op2 == 0x0) {
            // op1=0000 op2=0
            // SVE partition break condition
            RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 13, 10);
            RegIndex pn = (RegIndex)(uint8_t) bits(machInst, 8, 5);
            RegIndex pd = (RegIndex)(uint8_t) bits(machInst, 3, 0);
            uint8_t b_s_m = (bits(machInst, 23, 22) << 1) | bits(machInst, 4);
            switch (b_s_m) {
              case 0x0:   // B=0 S=0 M=0
                return new SveBrkaz(machInst, pd, pg, pn);
              case 0x1:   // B=0 S=0 M=1
                return new SveBrkam(machInst, pd, pg, pn);
              case 0x2:   // B=0 S=1 M=0
                return new SveBrkas(machInst, pd, pg, pn);
              case 0x4:   // B=1 S=0 M=0
                return new SveBrkbz(machInst, pd, pg, pn);
              case 0x5:   // B=1 S=0 M=1
                return new SveBrkbm(machInst, pd, pg, pn);
              case 0x6:   // B=1 S=1 M=0
                return new SveBrkbs(machInst, pd, pg, pn);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSvePartitionBreak

    // C4.1.59 SVE Predicate Misc
    StaticInstPtr
    decodeSvePredMisc(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 19, 16);
        uint8_t op1 = bits(machInst, 13, 11);
        uint8_t op2 = bits(machInst, 10, 9);
        uint8_t op3 = bits(machInst, 8, 5);
        uint8_t op4 = bits(machInst, 4);

        if (op0 == 0x0 && bits(op2, 0) == 0 && op4 == 0) {
            // op0=0000 op2=x0 op3=0
            // SVE predicate test
            uint8_t op_s = bits(machInst, 23, 22);
            uint8_t opc2 = bits(machInst, 3, 0);
            if (op_s == 0x1 && opc2 == 0) {   // op=0 S=1, opc2=0000
                RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
                RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 13, 10);
                return new SvePtest(machInst, pn, pg);
            }
        } else if (op0 == 0x8 && op1 == 0x0 && op2 == 0x0 && op4 == 0) {
            // op0=1000 op1=000 op2=00 op4=0
            // SVE predicate first active
            uint8_t op_s = bits(machInst, 23, 22);
            if (op_s == 0x1) {  // op=0 S=1
                RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 8, 5);
                RegIndex pdn = (RegIndex) (uint8_t) bits(machInst, 3, 0);
                return new SvePfirst<uint8_t>(machInst, pdn, pdn, pg);
            }
        } else if (op0 == 0x8 && op1 == 0x4 && op2 == 0x2 && !op3 && !op4) {
            // op0=1000 op1=100 op2=10 op3=0000 op4=0
            // SVE predicate zero
            uint8_t op_s = bits(machInst, 23, 22);
            if (op_s == 0x0) {  // op=0 S=0
                RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
                return new SvePfalse(machInst, pd);
            }
        } else if (op0 == 0x8 && op1 == 0x6 && op2 == 0x0) {
            // op0=1000 op1=110 op2=00
            // SVE predicate read from FFR (predicated)
            RegIndex pd = (RegIndex)(uint8_t) bits(machInst, 3, 0);
            RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 8, 5);
            uint8_t op_s = bits(machInst, 23, 22);
            if (op_s == 1)  {         // op=0 S=1
                return new SveRdffrsPred(machInst, pd, pg);
            } else if (op_s == 0)   { // op=0 S=0
                return new SveRdffrPred(machInst, pd, pg);
            }
        } else if (op0 == 0x9 && op1 == 0x0 && op2 == 0x2) {
            // op0=1001 op1=000 op2=10
            // PNEXT
            RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 8, 5);
            RegIndex pdn = (RegIndex) (uint8_t) bits(machInst, 3, 0);
            uint8_t size = bits(machInst, 23, 22);
            return decodeSveUnaryPredU<SvePnext>(size, machInst, pdn, pdn, pg);
        } else if (op0 == 0x9 && op1 == 0x6 && op2 == 0x0 && !op3 && !op4) {
            // op0=1001 op1=110 op2=00 op3=0000 op4=0
            // SVE predicate read from FFR (unpredicated)
            uint8_t op_s = bits(machInst, 23, 22);
            if (op_s == 0x0) {    // op=0 S=0
                RegIndex pd = (RegIndex)(uint8_t) bits(machInst, 3, 0);
                return new SveRdffrUnpred(machInst, pd);
            }
        } else if (bits(op0, 3, 1) == 0x4 && op1 == 0x4 &&
                    bits(op2, 1) == 0 && op4 == 0) {
            // op0=100x op2=100 op3=0x op4=0
            // SVE predicate initialize
            RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
            uint8_t imm = bits(machInst, 9, 5);
            uint8_t s = bits(machInst, 16);
            unsigned size = bits(machInst, 23, 22);
            if (s == 0x0) {
                return decodeSvePtrue<SvePtrue>(size, machInst, pd, imm);
            } else {
                return decodeSvePtrue<SvePtrues>(size, machInst, pd, imm);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSvePredMisc

    // C4.1.60 SVE Predicate Count
    StaticInstPtr
    decodeSvePredCount(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 13, 11);
        uint8_t op1 = bits(machInst, 9);

        if (op0 == 0x0 && op1 == 1) {   // op0=000 op1=1
            // SVE predicate count (predicate-as-counter)
            RegIndex rd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
            uint8_t vl = bits(machInst, 10);
            uint8_t opc = bits(machInst, 18, 16);
            uint8_t esize = bits(machInst, 23, 22);
            if (opc == 0x0) {   // opc=000
                return decodeSveBinImmUnpredU<SveCntpPng>(esize,
                        machInst, rd, pn, vl);
            }
        } else if (op1 == 0) {    // op0=xxxx op1=0
            // SVE predicate count
            RegIndex rd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
            RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
            RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 13, 10);
            uint8_t opc = bits(machInst, 18, 16);
            uint8_t esize = bits(machInst, 23, 22);
            if (opc == 0x0) {   // opc=000
                return decodeSveUnaryPredU<SveCntp>(esize,
                        machInst, rd, pn, pg);
            }
        }
        return new Unknown64(machInst);
    } // decodeSvePredCount

    // C4.1.61.1 SVE saturating inc/dec vector by predicate count
    StaticInstPtr
    decodeSveSatIncDecVecByPredCnt(ExtMachInst machInst)
    {
        uint8_t opc = bits(machInst, 10, 9);
        if (opc != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 8, 5);
        uint8_t d_u = bits(machInst, 17, 16);
        uint8_t esize = bits(machInst, 23, 22);

        switch (d_u) {
          case 0x0:   // D=0 U=0
            return decodeSvePredCountVS<SveSqincpv>(esize, machInst, zdn, pg);
          case 0x1:   // D=0 U=1
            return decodeSvePredCountVU<SveUqincpv>(esize, machInst, zdn, pg);
          case 0x2:   // D=1 U=0
            return decodeSvePredCountVS<SveSqdecpv>(esize, machInst, zdn, pg);
          case 0x3:   // D=1 U=1
            return decodeSvePredCountVU<SveUqdecpv>(esize, machInst, zdn, pg);
        }
        return new Unknown64(machInst);
    } // decodeSveSatIncDecVecByPredCnt

    // C4.1.61.2 SVE saturating inc/dec register by predicate count
    StaticInstPtr
    decodeSveSatIncDecRegByPredCnt(ExtMachInst machInst)
    {
        uint8_t op = bits(machInst, 9);
        if (op != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex rdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 8, 5);
        uint8_t d_u_sf = (bits(machInst, 17, 16) << 1) | bits(machInst, 10);
        uint8_t esize = bits(machInst, 23, 22);

        switch (d_u_sf) {
          case 0x0:   // D=0 U=0 sf=0 op=0
            return decodeSvePredCountS<SveSqincp32>(esize,
                    machInst, rdn, pg);
          case 0x1:   // D=0 U=0 sf=1 op=0
            return decodeSvePredCountS<SveSqincp64>(esize,
                    machInst, rdn, pg);
          case 0x2:   // D=0 U=1 sf=0 op=0
            return decodeSvePredCountU<SveUqincp32>(esize,
                    machInst, rdn, pg);
          case 0x3:   // D=0 U=1 sf=1 op=0
            return decodeSvePredCountU<SveUqincp64>(esize,
                    machInst, rdn, pg);
          case 0x4:   // D=1 U=0 sf=0 op=0
            return decodeSvePredCountS<SveSqdecp32>(esize,
                    machInst, rdn, pg);
          case 0x5:   // D=1 U=0 sf=1 op=0
            return decodeSvePredCountS<SveSqdecp64>(esize,
                    machInst, rdn, pg);
          case 0x6:   // D=1 U=1 sf=0 op=0
            return decodeSvePredCountU<SveUqdecp32>(esize,
                    machInst, rdn, pg);
          case 0x7:   // D=1 U=1 sf=1 op=0
            return decodeSvePredCountU<SveUqdecp64>(esize,
                    machInst, rdn, pg);
        }
        return new Unknown64(machInst);
    } // decodeSveSatIncDecRegByPredCnt

    // C4.1.61.3 SVE inc/dec vector by predicate count
    StaticInstPtr
    decodeSveIncDecVecByPredCnt(ExtMachInst machInst)
    {
        uint8_t op = bits(machInst, 17);
        uint8_t opc2 = bits(machInst, 10, 9);
        if (op != 0x0 || opc2 != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 8, 5);
        uint8_t d = bits(machInst, 16);
        uint8_t esize = bits(machInst, 23, 22);

        switch (d) {
          case 0x0:   // op=0 D=0 opc2=00
            return decodeSvePredCountVU<SveIncpv>(esize, machInst, zdn, pg);
          case 0x1:   // op=0 D=1 opc2=00
            return decodeSvePredCountVU<SveDecpv>(esize, machInst, zdn, pg);
        }
        return new Unknown64(machInst);
    } // decodeSveIncDecVecByPredCnt

    // C4.1.61.4 SVE inc/dec register by predicate count
    StaticInstPtr
    decodeSveIncDecRegByPredCnt(ExtMachInst machInst)
    {
        uint8_t op = bits(machInst, 17);
        uint8_t opc2 = bits(machInst, 10, 9);
        if (op != 0x0 || opc2 != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex rdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 8, 5);
        uint8_t d = bits(machInst, 16);
        uint8_t esize = bits(machInst, 23, 22);

        switch (d) {
          case 0x0:   // op=0 D=0 opc2=00
            return decodeSvePredCountU<SveIncp>(esize, machInst, rdn, pg);
          case 0x1:   // op=0 D=1 opc2=00
            return decodeSvePredCountU<SveDecp>(esize, machInst, rdn, pg);
        }
        return new Unknown64(machInst);
    } // decodeSveIncDecRegByPredCnt

    // C4.1.61 SVE Inc/Dec by Predicate Count
    StaticInstPtr
    decodeSveIncDecByPredCount(ExtMachInst machInst)
    {
        uint8_t op0_op1 = (bits(machInst, 18) << 1) | bits(machInst, 11);
        switch (op0_op1) {
          case 0x0:   // op0=0 op1=0
            return decodeSveSatIncDecVecByPredCnt(machInst);
          case 0x1:   // op0=0 op1=1
            return decodeSveSatIncDecRegByPredCnt(machInst);
          case 0x2:   // op0=1 op1=0
            return decodeSveIncDecVecByPredCnt(machInst);
          case 0x3:   // op0=1 op1=1
            return decodeSveIncDecRegByPredCnt(machInst);
        }
        return new Unknown64(machInst);
    } // decodeSveIncDecByPredCount

    // C4.1.62 SVE Write FFR
    StaticInstPtr
    decodeSveWriteFfr(ExtMachInst machInst)
    {
        uint8_t op0_op1 = bits(machInst, 18, 16);
        uint8_t op2 = bits(machInst, 11, 9);
        uint8_t op3 = bits(machInst, 8, 5);
        uint8_t op4 = bits(machInst, 4, 0);
        if (op0_op1 == 0x0 && op2 == 0x0 && op4 == 0x0) {
            // op0=0 op1=00 op2=000 op4=00000
            // SVE FFR write from predicate
            uint8_t opc = bits(machInst, 23, 22);
            if (opc == 0) {
                RegIndex pn = (RegIndex)(uint8_t) bits(machInst, 8, 5);
                return new SveWrffr(machInst, pn);
            }
        } else if (op0_op1 == 0x4 && op2 == 0x0 && op3 == 0x0 && op4 == 0x0) {
            // op0=1 op1=00 op2=000 op3=0000 op4=00000
            // SVE FFR initialise
            uint8_t opc = bits(machInst, 23, 22);
            if (opc == 0) {
                return new SveSetffr(machInst);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveWriteFfr

    // C4.1.63.1 SVE integer compare scalar count and limit
    StaticInstPtr
    decodeSveIntCompScaCountAndLimit(ExtMachInst machInst)
    {
        RegIndex rn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        uint8_t u_lt_eq = (uint8_t) bits(machInst, 11, 10) << 1 |
            bits(machInst, 4);
        uint8_t s64b = (uint8_t) bits(machInst, 12);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (s64b) {
            switch (u_lt_eq) {
              case 0x0: // U=0, lt=0, eq=0
                return decodeSveBinUnpredS<SveWhilege64>(size,
                        machInst, pd, rn, rm);
              case 0x1: // U=0, lt=0, eq=1
                return decodeSveBinUnpredS<SveWhilegt64>(size,
                        machInst, pd, rn, rm);
              case 0x2: // U=0, lt=1, eq=0
                return decodeSveBinUnpredS<SveWhilelt64>(size,
                        machInst, pd, rn, rm);
              case 0x3: // U=0, lt=1, eq=1
                return decodeSveBinUnpredS<SveWhilele64>(size,
                        machInst, pd, rn, rm);
              case 0x4: // U=1, lt=0, eq=0
                return decodeSveBinUnpredU<SveWhilehs64>(size,
                        machInst, pd, rn, rm);
              case 0x5: // U=1, lt=0, eq=1
                return decodeSveBinUnpredU<SveWhilehi64>(size,
                        machInst, pd, rn, rm);
              case 0x6: // U=1, lt=1, eq=0
                return decodeSveBinUnpredU<SveWhilelo64>(size,
                        machInst, pd, rn, rm);
              case 0x7: // U=1, lt=1, eq=1
                return decodeSveBinUnpredU<SveWhilels64>(size,
                        machInst, pd, rn, rm);
            }
        } else {
            switch (u_lt_eq) {
              case 0x0: // U=0, lt=0, eq=0
                return decodeSveBinUnpredS<SveWhilege32>(size,
                        machInst, pd, rn, rm);
              case 0x1: // U=0, lt=0, eq=1
                return decodeSveBinUnpredS<SveWhilegt32>(size,
                        machInst, pd, rn, rm);
              case 0x2: // U=0, lt=1, eq=0
                return decodeSveBinUnpredS<SveWhilelt32>(size,
                        machInst, pd, rn, rm);
              case 0x3: // U=0, lt=1, eq=1
                return decodeSveBinUnpredS<SveWhilele32>(size,
                        machInst, pd, rn, rm);
              case 0x4: // U=1, lt=0, eq=0
                return decodeSveBinUnpredU<SveWhilehs32>(size,
                        machInst, pd, rn, rm);
              case 0x5: // U=1, lt=0, eq=1
                return decodeSveBinUnpredU<SveWhilehi32>(size,
                        machInst, pd, rn, rm);
              case 0x6: // U=1, lt=1, eq=0
                return decodeSveBinUnpredU<SveWhilelo32>(size,
                        machInst, pd, rn, rm);
              case 0x7: // U=1, lt=0, eq=1
                return decodeSveBinUnpredU<SveWhilels32>(size,
                        machInst, pd, rn, rm);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCompScaCountAndLimit

    // C4.1.63.2 SVE conditionally terminate scalars
    StaticInstPtr
    decodeSveCondTermSca(ExtMachInst machInst)
    {
        uint8_t op = bits(machInst, 23);
        if (op != 0x1) {
            return new Unknown64(machInst);
        }

        RegIndex rn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t ne = bits(machInst, 4);
        uint8_t size = bits(machInst, 23, 22);

        if (ne == 0x0) {        // op=1, ne=0
            if (size == 0x2) {
                return new SveCtermeq<uint32_t>(machInst, rn, rm);
            } else if (size == 0x3) {
                return new SveCtermeq<uint64_t>(machInst, rn, rm);
            }
        } else if (ne == 0x1) { // op=1, ne=1
            if (size == 0x2) {
                return new SveCtermne<uint32_t>(machInst, rn, rm);
            } else if (size == 0x3) {
                return new SveCtermne<uint64_t>(machInst, rn, rm);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveCondTermSca

    // C4.1.63.3 SVE pointer conflict compare
    StaticInstPtr
    decodeSvePointerConfComp(ExtMachInst machInst)
    {
        RegIndex rn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        uint8_t rw = (uint8_t) bits(machInst, 4);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (rw == 0) {
            return decodeSveBinUnpredU<SveWhilewr>(size, machInst, pd, rn, rm);
        } else {
            return decodeSveBinUnpredU<SveWhilerw>(size, machInst, pd, rn, rm);
        }
        return new Unknown64(machInst);
    }  // decodeSvePointerConfComp

    // C4.1.63 SVE Integer Compare - Scalars
    StaticInstPtr
    decodeSveIntCmpSca(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 13, 12);
        uint8_t op1 = bits(machInst, 11, 10);
        uint8_t op2 = bits(machInst, 3, 0);
        if (bits(op0, 1) == 0) {    // op0=0x
            return decodeSveIntCompScaCountAndLimit(machInst);
        } else if (op0 == 0x2 && op1 == 0x0 && op2 == 0x0) {
            // op0=10 op1=00 op2=0000
            return decodeSveCondTermSca(machInst);
        } else if (op0 == 0x3 && op1 == 0x0) {  // op0=11 op1=00
            return decodeSvePointerConfComp(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpSca

    // C4.1.64.1 SVE extract mask predicate from predicate-as-counter
    StaticInstPtr
    decodeSveExtMaskPrefFromPng(ExtMachInst machInst)
    {
        RegIndex Pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex Pn = (RegIndex)(0b1000 + (uint8_t) bits(machInst, 7, 5));
        uint8_t opc = bits(machInst, 10, 8);
        uint8_t size = bits(machInst, 23, 22);

        if (bits(opc, 2) == 0)  {   // opc=0xx
            // PEXT (predicate)
            uint8_t imm2 = bits(machInst, 9, 8);
            switch (size) {
              case 0x0:
                return new SvePext<uint8_t>(machInst, Pd, Pn, imm2);
              case 0x1:
                return new SvePext<uint16_t>(machInst, Pd, Pn, imm2);
              case 0x2:
                return new SvePext<uint32_t>(machInst, Pd, Pn, imm2);
              case 0x3:
                return new SvePext<uint64_t>(machInst, Pd, Pn, imm2);
            }
        } else if (bits(opc, 1) == 0) {   // opc=10x
            // PEXT (predicate pair)
            RegIndex Pd2 = (RegIndex)((Pd + 1) % 16);
            uint8_t i1 = bits(machInst, 8);
            switch (size) {
              case 0x0:
                return new SvePextPair<uint8_t>(machInst, Pd, Pd2, Pn, i1);
              case 0x1:
                return new SvePextPair<uint16_t>(machInst, Pd, Pd2, Pn, i1);
              case 0x2:
                return new SvePextPair<uint32_t>(machInst, Pd, Pd2, Pn, i1);
              case 0x3:
                return new SvePextPair<uint64_t>(machInst, Pd, Pd2, Pn, i1);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveExtMaskPrefFromPng

    // C4.1.64.2 SVE integer compare scalar count and limit (predicate pair)
    StaticInstPtr
    decodeSveIntCmpScaCntAndLimitPredPair(ExtMachInst machInst)
    {
        RegIndex rn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pd = (RegIndex)((uint8_t) bits(machInst, 3, 1) * 2);
        RegIndex pd2 = (RegIndex)((uint8_t) bits(machInst, 3, 1) * 2 + 1);
        uint8_t u_lt_eq = (uint8_t) bits(machInst, 11, 10) << 1 |
            bits(machInst, 0);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (u_lt_eq) {
          case 0x0: // U=0, lt=0, eq=0
            return decodeSveWhileUnpredS<SveWhilegePair>(size,
                    machInst, pd, pd2, rn, rm);
          case 0x1: // U=0, lt=0, eq=1
            return decodeSveWhileUnpredS<SveWhilegtPair>(size,
                    machInst, pd, pd2, rn, rm);
          case 0x2: // U=0, lt=1, eq=0
            return decodeSveWhileUnpredS<SveWhileltPair>(size,
                    machInst, pd, pd2, rn, rm);
          case 0x3: // U=0, lt=1, eq=1
            return decodeSveWhileUnpredS<SveWhilelePair>(size,
                    machInst, pd, pd2, rn, rm);
          case 0x4: // U=1, lt=0, eq=0
            return decodeSveWhileUnpredU<SveWhilehsPair>(size,
                    machInst, pd, pd2, rn, rm);
          case 0x5: // U=1, lt=0, eq=1
            return decodeSveWhileUnpredU<SveWhilehiPair>(size,
                    machInst, pd, pd2, rn, rm);
          case 0x6: // U=1, lt=1, eq=0
            return decodeSveWhileUnpredU<SveWhileloPair>(size,
                    machInst, pd, pd2, rn, rm);
          case 0x7: // U=1, lt=1, eq=1
            return decodeSveWhileUnpredU<SveWhilelsPair>(size,
                    machInst, pd, pd2, rn, rm);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpScaCntAndLimitPredPair

    // C4.1.64.3 SVE integer compare scalar count and limit
    // (predicate-as-counter)
    StaticInstPtr
    decodeSveIntCmpScaCntAndLimitPng(ExtMachInst machInst)
    {
        RegIndex rn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pd = (RegIndex)(0b1000 + (uint8_t) bits(machInst, 2, 0));
        uint8_t u_lt_eq = (uint8_t) bits(machInst, 11, 10) << 1 |
            bits(machInst, 3);
        uint8_t vl = (uint8_t) bits(machInst, 13);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (u_lt_eq) {
          case 0x0: // U=0, lt=0, eq=0
            return decodeSveWhilePngUnpredS<SveWhilegePng>(size,
                    machInst, pd, rn, rm, vl);
          case 0x1: // U=0, lt=0, eq=1
            return decodeSveWhilePngUnpredS<SveWhilegtPng>(size,
                    machInst, pd, rn, rm, vl);
          case 0x2: // U=0, lt=1, eq=0
            return decodeSveWhilePngUnpredS<SveWhileltPng>(size,
                    machInst, pd, rn, rm, vl);
          case 0x3: // U=0, lt=1, eq=1
            return decodeSveWhilePngUnpredS<SveWhilelePng>(size,
                    machInst, pd, rn, rm, vl);
          case 0x4: // U=1, lt=0, eq=0
            return decodeSveWhilePngUnpredU<SveWhilehsPng>(size,
                    machInst, pd, rn, rm, vl);
          case 0x5: // U=1, lt=0, eq=1
            return decodeSveWhilePngUnpredU<SveWhilehiPng>(size,
                    machInst, pd, rn, rm, vl);
          case 0x6: // U=1, lt=1, eq=0
            return decodeSveWhilePngUnpredU<SveWhileloPng>(size,
                    machInst, pd, rn, rm, vl);
          case 0x7: // U=1, lt=1, eq=1
            return decodeSveWhilePngUnpredU<SveWhilelsPng>(size,
                    machInst, pd, rn, rm, vl);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpScaCntAndLimitPng

    // C4.1.64 SVE Scalar Integer Compare - Predicate-as-counter
    StaticInstPtr
    decodeSveScaIntCmpPng(ExtMachInst machInst)
    {
        uint8_t op1 = bits(machInst, 13, 11);
        switch (op1) {
          case 0x0: case 0x1: case 0x4: case 0x5: // op1=x0x
            return decodeSveIntCmpScaCntAndLimitPng(machInst);
          case 0x2: case 0x3:   // op1=01x
            return decodeSveIntCmpScaCntAndLimitPredPair(machInst);
          case 0x6:   // op1=110
            {
                uint8_t op0 = bits(machInst, 20, 16);
                if (op0 == 0x0) {
                    return decodeSveExtMaskPrefFromPng(machInst);
                }
            }
            break;
          case 0x7:   // op1=111
            {
                uint8_t op0 = bits(machInst, 20, 16);
                uint8_t op2 = bits(machInst, 10, 5);
                uint8_t op3 = bits(machInst, 3);
                if (op0 == 0x0 && op2 == 0x0 && op3 == 0) {
                    // op0=00000 op1=111 op2=000000 op3=0
                    // PTRUE (predicate as counter)
                    RegIndex pd = (RegIndex)(0b1000 +
                                      (uint8_t)bits(machInst, 2, 0));
                    unsigned size = bits(machInst, 23, 22);
                    return decodeSvePtrue<SvePtruePng>(size, machInst, pd, 0);
                }
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveScaIntCmpPng

    // C4.1.65.1 SVE integer add/subtract immediate (unpredicated)
    StaticInstPtr
    decodeSveIntAddSubImmUnpred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint64_t imm = bits(machInst, 12, 5);
        uint8_t sh = bits(machInst, 13);
        uint8_t opc = bits(machInst, 18, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (sh) {
            if (size == 0x0) {
                return new Unknown64(machInst);
            }
            imm <<= 8;
        }

        switch (opc) {
          case 0x0:   // opc=000
            return decodeSveWideImmUnpredU<SveAddImm>(
                size, machInst, zdn, imm);
          case 0x1:   // opc=001
            return decodeSveWideImmUnpredU<SveSubImm>(
                size, machInst, zdn, imm);
          case 0x3:   // opc=011
            return decodeSveWideImmUnpredU<SveSubrImm>(
                size, machInst, zdn, imm);
          case 0x4:   // opc=100
            return decodeSveWideImmUnpredS<SveSqaddImm>(
                size, machInst, zdn, imm);
          case 0x5:   // opc=101
            return decodeSveWideImmUnpredU<SveUqaddImm>(
                size, machInst, zdn, imm);
          case 0x6:   // opc=110
            return decodeSveWideImmUnpredS<SveSqsubImm>(
                size, machInst, zdn, imm);
          case 0x7:   // opc=111
            return decodeSveWideImmUnpredU<SveUqsubImm>(
                size, machInst, zdn, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntAddSubImmUnpred

    // C4.1.65.2 SVE integer min/max immediate (unpredicated)
    StaticInstPtr
    decodeSveIntMinMaxImmUnpred(ExtMachInst machInst)
    {
        uint8_t o2 = bits(machInst, 13);
        if (o2 != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint64_t imm = bits(machInst, 12, 5);
        uint8_t opc = bits(machInst, 18, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=000 o2=0
            return decodeSveWideImmUnpredS<SveSmaxImm>(
                size, machInst, zdn, sext<8>(imm));
          case 0x1:   // opc=001 o2=0
            return decodeSveWideImmUnpredU<SveUmaxImm>(
                size, machInst, zdn, imm);
          case 0x2:   // opc=010 o2=0
            return decodeSveWideImmUnpredS<SveSminImm>(
                size, machInst, zdn, sext<8>(imm));
          case 0x3:   // opc=011 o2=0
            return decodeSveWideImmUnpredU<SveUminImm>(
                size, machInst, zdn, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMinMaxImmUnpred

    // C4.1.65.3 SVE integer multiply immediate (unpredicated)
    StaticInstPtr
    decodeSveIntMulImmUnpred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint64_t imm = bits(machInst, 12, 5);
        uint8_t opc_o2 = (bits(machInst, 18, 16) << 1) | bits(machInst, 13);
        uint8_t size = bits(machInst, 23, 22);

        if (opc_o2 == 0x0) {  // opc=000 o2=0
            return decodeSveWideImmUnpredU<SveMulImm>(
                size, machInst, zdn, sext<8>(imm));
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMulImmUnpred

    // C4.1.65.4 SVE broadcast integer immediate (unpredicated)
    StaticInstPtr
    decodeSveBroadIntImmUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint64_t imm = bits(machInst, 12, 5);
        uint8_t sh = bits(machInst, 13);
        uint8_t opc = bits(machInst, 18, 17);
        uint8_t size = bits(machInst, 23, 22);

        if (sh) {
            if (size == 0x0) {
                return new Unknown64(machInst);
            }
            imm <<= 8;
        }

        if (opc == 0x0) {   // opc=00
            if (sh) {
                return decodeSveWideImmUnpredU<SveDupImm>(
                    size, machInst, zd, sext<16>(imm));
            } else {
                return decodeSveWideImmUnpredU<SveDupImm>(
                    size, machInst, zd, sext<8>(imm));
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveBroadIntImmUnpred

    // C4.1.65.5 SVE broadcast floating-point immediate (unpredicated)
    StaticInstPtr
    decodeSveBroadFpImmUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint8_t opc_o2 = (bits(machInst, 18, 17) << 1) | bits(machInst, 13);
        uint8_t size = bits(machInst, 23, 22);

        if (opc_o2 == 0x0 && size != 0x0) {  // opc=00 o2=0
            uint64_t imm = vfp_modified_imm(bits(machInst, 12, 5),
                decode_fp_data_type(size));
            return decodeSveWideImmUnpredF<SveFdup>(size, machInst, zd, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSveBroadFpImmUnpred

    // C4.1.65 SVE Integer Wide Immediate - Unpredicated
    StaticInstPtr
    decodeSveIntWideImmUnpred(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 20, 19);
        uint8_t op1 = bits(machInst, 16);
        switch (op0) {
          case 0x0:   // op0=00
            return decodeSveIntAddSubImmUnpred(machInst);
          case 0x1:   // op0=01
            return decodeSveIntMinMaxImmUnpred(machInst);
          case 0x2:   // op0=10
            return decodeSveIntMulImmUnpred(machInst);
          case 0x3:   // op0=11
            if (op1 == 0x0) { // op0=11 op1=0
                return decodeSveBroadIntImmUnpred(machInst);
            } else {          // op0=11 op1=1
                return decodeSveBroadFpImmUnpred(machInst);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveIntWideImmUnpred

    // C4.1.66.1 SVE integer dot product (unpredicated)
    StaticInstPtr
    decodeSveIntDotProdUnpred(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t usig = (uint8_t) bits(machInst, 10);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (size == 0x3) {
            if (usig) {
                return new SveUdotv<uint16_t, uint16_t, uint64_t>(
                        machInst, zda, zn, zm);
            } else {
                return new SveSdotv<int16_t, int16_t, int64_t>(
                        machInst, zda, zn, zm);
            }
        } else if (size == 0x2) {
            if (usig) {
                return new SveUdotv<uint8_t, uint8_t, uint32_t>(
                        machInst, zda, zn, zm);
            } else {
                return new SveSdotv<int8_t, int8_t, int32_t>(
                        machInst, zda, zn, zm);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveIntDotProdUnpred

    // C4.1.66.2 SVE2 saturating multiply-add interleaved long
    StaticInstPtr
    decodeSve2SatMulAddInterLong(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t s = bits(machInst, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (s) {
          case 0x0: // S=0
            return decodeSveBinUnpredUnequalS<SveSqdmlalbt>(
                    size, machInst, zd, zn, zm);
          case 0x1: // S=1
            return decodeSveBinUnpredUnequalS<SveSqdmlslbt>(
                    size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2SatMulAddInterLong

    // C4.1.66.3 SVE2 complex integer multiply-add
    StaticInstPtr
    decodeSve2CplxIntMulAdd(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t rot = bits(machInst, 11, 10);
        uint8_t op = bits(machInst, 12);
        uint8_t size = bits(machInst, 23, 22);

        if (op == 0) {
            switch (size) {
              case 0:
                return new SveCmlav<int8_t>(machInst, zda, zn, zm, rot);
              case 1:
                return new SveCmlav<int16_t>(machInst, zda, zn, zm, rot);
              case 2:
                return new SveCmlav<int32_t>(machInst, zda, zn, zm, rot);
              case 3:
                return new SveCmlav<int64_t>(machInst, zda, zn, zm, rot);
            }
        } else {
            switch (size) {
              case 0:
                return new SveSqrdcmlahv<int8_t>(machInst, zda, zn, zm, rot);
              case 1:
                return new SveSqrdcmlahv<int16_t>(machInst, zda, zn, zm, rot);
              case 2:
                return new SveSqrdcmlahv<int32_t>(machInst, zda, zn, zm, rot);
              case 3:
                return new SveSqrdcmlahv<int64_t>(machInst, zda, zn, zm, rot);
            }
        }
        return new Unknown64(machInst);
    } // decodeSve2CplxIntMulAdd

    // C4.1.66.4 SVE2 integer multiply-add long
    StaticInstPtr
    decodeSve2IntMulAddLong(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t s_u_t = bits(machInst, 12, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (s_u_t) {
          case 0x0: // S=0 U=0 T=0
            return decodeSveBinUnpredUnequalS<SveSmlalb>(
                    size, machInst, zd, zn, zm);
          case 0x1: // S=0 U=0 T=1
            return decodeSveBinUnpredUnequalS<SveSmlalt>(
                    size, machInst, zd, zn, zm);
          case 0x2: // S=0 U=1 T=0
            return decodeSveBinUnpredUnequalU<SveUmlalb>(
                    size, machInst, zd, zn, zm);
          case 0x3: // S=0 U=1 T=1
            return decodeSveBinUnpredUnequalU<SveUmlalt>(
                    size, machInst, zd, zn, zm);
          case 0x4: // S=1 U=0 T=0
            return decodeSveBinUnpredUnequalS<SveSmlslb>(
                    size, machInst, zd, zn, zm);
          case 0x5: // S=1 U=0 T=1
            return decodeSveBinUnpredUnequalS<SveSmlslt>(
                    size, machInst, zd, zn, zm);
          case 0x6: // S=1 U=1 T=0
            return decodeSveBinUnpredUnequalU<SveUmlslb>(
                    size, machInst, zd, zn, zm);
          case 0x7: // S=1 U=1 T=1
            return decodeSveBinUnpredUnequalU<SveUmlslt>(
                    size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntMulAddLong

    // C4.1.66.5 SVE2 saturating multiply-add long
    StaticInstPtr
    decodeSve2SatMulAddLong(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t s_t = bits(machInst, 11, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (s_t) {
          case 0x0:   // S=0 T=0
            return decodeSveBinUnpredUnequalS<SveSqdmlalb>(
                    size, machInst, zd, zn, zm);
          case 0x1:   // S=0 T=1
            return decodeSveBinUnpredUnequalS<SveSqdmlalt>(
                    size, machInst, zd, zn, zm);
          case 0x2:   // S=1 T=0
            return decodeSveBinUnpredUnequalS<SveSqdmlslb>(
                    size, machInst, zd, zn, zm);
          case 0x3:   // S=1 T=1
            return decodeSveBinUnpredUnequalS<SveSqdmlslt>(
                    size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2SatMulAddLong

    // C4.1.66.6 SVE2 saturating multiply-add high (indexed)
    StaticInstPtr
    decodeSve2SatMulAddHigh(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t s = (uint8_t) bits(machInst, 10);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (s) {
          case 0x0: // s=0
            return decodeSveBinUnpredS<SveSqrdmlah>(
                    size, machInst, zda, zn, zm);
          case 0x1: // s=1
            return decodeSveBinUnpredS<SveSqrdmlsh>(
                    size, machInst, zda, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2SatMulAddHigh

    // C4.1.66.7 SVE mixed sign dot product
    StaticInstPtr
    decodeSveMixedSignDotProd(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (size == 0x2) {
            return new SveUsdotv<uint8_t, int8_t, int32_t>(
                    machInst, zda, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSveMixedSignDotProd

    // C4.1.66 SVE Integer Multiply-Add - Unpredicated
    StaticInstPtr
    decodeSveIntMulAddUnpred(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 14, 10);
        if (bits(op0, 4) == 0) {
            if (bits(op0, 3) == 1) {  // op0=01xxx
                return decodeSve2CplxIntMulAdd(machInst);
            } else if (bits(op0, 2) == 1) { // op0=001xx
                // CDOT (vectors)
                RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
                uint8_t rot = bits(machInst, 11, 10);
                uint8_t size = bits(machInst, 23, 22);

                if (size == 2) {
                    return new SveCdotv<int8_t, int8_t, int32_t>(
                            machInst, zda, zn, zm, rot);
                } else if (size == 3) {
                    return new SveCdotv<int16_t, int16_t, int64_t>(
                            machInst, zda, zn, zm, rot);
                }
            } else if (bits(op0, 1) == 1) { // op0=0001x
                return decodeSve2SatMulAddInterLong(machInst);
            } else {  // op0=0000x
                return decodeSveIntDotProdUnpred(machInst);
            }
        } else {
            if (bits(op0, 3) == 0) {  // op0=10xxx
                return decodeSve2IntMulAddLong(machInst);
            } else if (bits(op0, 2) == 0) { // op0=110xx
                return decodeSve2SatMulAddLong(machInst);
            } else if (bits(op0, 1) == 0) { // op0=1110x
                return decodeSve2SatMulAddHigh(machInst);
            } else if (bits(op0, 0) == 0) { // op0=11110
                return decodeSveMixedSignDotProd(machInst);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMulAddUnpred

    // C4.1.67.1 SVE2 integer pairwise add and accumulate long
    StaticInstPtr
    decodeSve2IntPairAddAccLong(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t u = bits(machInst, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (u) {
          case 0x0: // U=0
            return decodeSveBinPredPairLongS<SveSadalp>(
                    size, machInst, zda, zn, pg);
          case 0x1: // U=1
            return decodeSveBinPredPairLongU<SveUadalp>(
                    size, machInst, zda, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSve2SatRoundBitwiseShiftLeftPred

    // C4.1.67.2 SVE2 integer unary operations (predicated)
    StaticInstPtr
    decodeSve2IntUnaryOpPred(ExtMachInst machInst)
    {
        uint8_t z = bits(machInst, 17);
        if (z != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t q_op = (bits(machInst, 19) << 1) | bits(machInst, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (q_op) {
          case 0x0: // q=0 z=0 op=0
            if (size == 2) {
                return new SveUrecpe<uint32_t>(machInst, zd, zn, pg);
            }
            break;
          case 0x1: // q=0 z=0 op=1
            if (size == 2) {
                return new SveUrsqrte<uint32_t>(machInst, zd, zn, pg);
            }
            break;
          case 0x2: // q=1 z=0 op=0
            return decodeSveUnaryPredS<SveSqabs>(size, machInst, zd, zn, pg);
          case 0x3: // q=1 z=0 op=1
            return decodeSveUnaryPredS<SveSqneg>(size, machInst, zd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntUnaryOpPred

    // C4.1.67.3 SVE2 saturating/rounding bitwise shift left (predicated)
    StaticInstPtr
    decodeSve2SatRoundBitwiseShiftLeftPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t u = bits(machInst, 16);
        uint8_t q_r_n = bits(machInst, 19, 17);
        uint8_t size = bits(machInst, 23, 22);

        switch (q_r_n) {
          case 0x1: // q=0 r=0 n=1
            return decodeSveBinDestrPred<SveSrshl, SveUrshl>(
                    size, u, machInst, zdn, zm, pg);
          case 0x3: // q=0 r=1 n=1
            return decodeSveBinDestrPred<SveSrshlr, SveUrshlr>(
                    size, u, machInst, zdn, zm, pg);
          case 0x4: // q=1 r=0 n=0
            return decodeSveBinDestrPred<SveSqshl, SveUqshl>(
                    size, u, machInst, zdn, zm, pg);
          case 0x5: // q=1 r=0 n=1
            return decodeSveBinDestrPred<SveSqrshl, SveUqrshl>(
                    size, u, machInst, zdn, zm, pg);
          case 0x6: // q=1 r=1 n=0
            return decodeSveBinDestrPred<SveSqshlr, SveUqshlr>(
                    size, u, machInst, zdn, zm, pg);
          case 0x7: // q=1 r=1 n=1
            return decodeSveBinDestrPred<SveSqrshlr, SveUqrshlr>(
                    size, u, machInst, zdn, zm, pg);
        }

        return new Unknown64(machInst);
    }  // decodeSve2SatRoundBitwiseShiftLeftPred

    // C4.1.67.4 SVE2 integer halving add/subtract (predicated)
    StaticInstPtr
    decodeSve2IntHalvingAddSubPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t u = bits(machInst, 16);
        uint8_t r_s = bits(machInst, 18, 17);
        uint8_t size = bits(machInst, 23, 22);

        switch (r_s) {
          case 0x0:
            return decodeSveBinDestrPred<SveShadd, SveUhadd>(
                    size, u, machInst, zdn, zm, pg);
          case 0x1:
            return decodeSveBinDestrPred<SveShsub, SveUhsub>(
                    size, u, machInst, zdn, zm, pg);
          case 0x2:
            return decodeSveBinDestrPred<SveSrhadd, SveUrhadd>(
                    size, u, machInst, zdn, zm, pg);
          case 0x3:
            return decodeSveBinDestrPred<SveShsubr, SveUhsubr>(
                    size, u, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntHalvingAddSubPred

    // C4.1.67.5 SVE2 integer pairwise arithmetic
    StaticInstPtr
    decodeSve2IntPairArith(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t u = bits(machInst, 16);
        uint8_t opc = bits(machInst, 18, 17);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=00
            if (u == 1) {
                return decodeSveBinDestrPredU<SveAddp>(
                        size, machInst, zdn, zm, pg);
            }
            break;
          case 0x2:   // opc=10
            return decodeSveBinDestrPred<SveSmaxp, SveUmaxp>(
                    size, u, machInst, zdn, zm, pg);
          case 0x3:   // opc=11
            return decodeSveBinDestrPred<SveSminp, SveUminp>(
                    size, u, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntPairArith

    // C4.1.67.6 SVE2 saturating add/subtract
    StaticInstPtr
    decodeSve2SatAddSub(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t u = bits(machInst, 16);
        uint8_t op_s = bits(machInst, 18, 17);
        uint8_t size = bits(machInst, 23, 22);

        switch (op_s) {
          case 0x0: // op=0 S=0
            return decodeSveBinDestrPred<SveSqaddPred, SveUqaddPred>(
                    size, u, machInst, zdn, zm, pg);
          case 0x1: // op=0 S=1
            return decodeSveBinDestrPred<SveSqsubPred, SveUqsubPred>(
                    size, u, machInst, zdn, zm, pg);
          case 0x2: // op=1 S=0
            if (u == 0) {
                return decodeSveBinDestrPredU<SveSuqaddPred>(
                        size, machInst, zdn, zm, pg);
            } else {
                return decodeSveBinDestrPredU<SveUsqaddPred>(
                        size, machInst, zdn, zm, pg);
            }
          case 0x3: // op=1 S=1
            return decodeSveBinDestrPred<SveSqsubrPred, SveUqsubrPred>(
                    size, u, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSve2SatAddSub

    // C4.1.67 SVE2 Integer - Predicated
    StaticInstPtr
    decodeSve2IntPred(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 20, 17);
        uint8_t op1 = bits(machInst, 13);
        if (op1 == 0) {
            if (bits(op0, 3) == 0) {  // op0=0xxx, op1=0
                return decodeSve2SatRoundBitwiseShiftLeftPred(machInst);
            } else if (bits(op0, 2) == 0) { // op0=10xx, op1=0
                return decodeSve2IntHalvingAddSubPred(machInst);
            } else {  // op0=11xx, op1=0
                return decodeSve2SatAddSub(machInst);
            }
        } else {
            if (op0 == 0x2) {  // op0=0010, op1=1
                return decodeSve2IntPairAddAccLong(machInst);
            } else if (bits(op0, 3) == 0 && bits(op0, 1) == 0) {
                // op0=0x0x, op1=1
                return decodeSve2IntUnaryOpPred(machInst);
            } else if (bits(op0, 3, 2) == 0x2) { // op0=10xx, op1=1
                return decodeSve2IntPairArith(machInst);
            }
        }
        return new Unknown64(machInst);
    }

    // C4.1.68.1 SVE integer dot product (indexed)
    StaticInstPtr
    decodeSveIntDotProdIndexed(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t usig = (uint8_t) bits(machInst, 10);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (size == 0x3) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
            uint8_t i1 = (uint8_t) bits(machInst, 20);
            if (usig) {
                return new SveUdoti<uint16_t, uint16_t, uint64_t>(
                        machInst, zda, zn, zm, i1);
            } else {
                return new SveSdoti<int16_t, int16_t, int64_t>(
                        machInst, zda, zn, zm, i1);
            }
        } else if (size == 0x2) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
            uint8_t i2 = (uint8_t) bits(machInst, 20, 19);
            if (usig) {
                return new SveUdoti<uint8_t, uint8_t, uint32_t>(
                        machInst, zda, zn, zm, i2);
            } else {
                return new SveSdoti<int8_t, int8_t, int32_t>(
                        machInst, zda, zn, zm, i2);
            }
        }
        return new Unknown64(machInst);
    } // decodeSveIntDotProdIndexed

    // C4.1.68.2 SVE2 integer multiply-add (indexed)
    StaticInstPtr
    decodeSve2IntMulAddIndexed(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t s = bits(machInst, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch(size) {
          case 0x0: case 0x1:
            {
                RegIndex zm_16 = (RegIndex)(uint8_t)bits(machInst, 18, 16);
                uint8_t imm_16 = (uint8_t)(bits(machInst, 22) << 2)
                | bits(machInst, 20, 19);
                switch(s) {
                  case 0x0:
                    return new Sve2Mlai<int16_t>(
                            machInst, zda, zn, zm_16, imm_16);
                  case 0x1:
                    return new Sve2Mlsi<int16_t>(
                            machInst, zda, zn, zm_16, imm_16);
                }
            }
            break;
          case 0x2:
            {
                RegIndex zm_32 = (RegIndex)(uint8_t)bits(machInst, 18, 16);
                uint8_t imm_32 = (uint8_t)bits(machInst, 20, 19);
                switch(s) {
                  case 0x0:
                    return new Sve2Mlai<int32_t>(
                            machInst, zda, zn, zm_32, imm_32);
                  case 0x1:
                    return new Sve2Mlsi<int32_t>(
                            machInst, zda, zn, zm_32, imm_32);
                }
            }
            break;
          case 0x3:
            {
                RegIndex zm_64 = (RegIndex)(uint8_t)bits(machInst, 19, 16);
                uint8_t imm_64 = (uint8_t)bits(machInst, 20);
                switch(s) {
                  case 0x0:
                    return new Sve2Mlai<int64_t>(
                            machInst, zda, zn, zm_64, imm_64);
                  case 0x1:
                    return new Sve2Mlsi<int64_t>(
                            machInst, zda, zn, zm_64, imm_64);
                }
            }
            break;
        }

        return new Unknown64(machInst);
    } // decodeSve2IntMulAddIndexed

    // C4.1.68.3 SVE2 saturating multiply-add high (indexed)
    StaticInstPtr
    decodeSve2SatMulAddHighIndexed(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t s = bits(machInst, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch(size) {
          case 0x0: case 0x1:
            {
                RegIndex zm_16 = (RegIndex)(uint8_t)bits(machInst, 18, 16);
                uint8_t imm_16 = (uint8_t)(bits(machInst, 22) << 2)
                | bits(machInst, 20, 19);
                switch(s) {
                  case 0x0:
                    return new SveSqrdmlahIdx<int16_t>(
                            machInst, zda, zn, zm_16, imm_16);
                  case 0x1:
                    return new SveSqrdmlshIdx<int16_t>(
                            machInst, zda, zn, zm_16, imm_16);
                }
            }
            break;
          case 0x2:
            {
                RegIndex zm_32 = (RegIndex)(uint8_t)bits(machInst, 18, 16);
                uint8_t imm_32 = (uint8_t)bits(machInst, 20, 19);
                switch(s) {
                  case 0x0:
                    return new SveSqrdmlahIdx<int32_t>(
                            machInst, zda, zn, zm_32, imm_32);
                  case 0x1:
                    return new SveSqrdmlshIdx<int32_t>(
                            machInst, zda, zn, zm_32, imm_32);
                }
            }
            break;
          case 0x3:
            {
                RegIndex zm_64 = (RegIndex)(uint8_t)bits(machInst, 19, 16);
                uint8_t imm_64 = (uint8_t)bits(machInst, 20);
                switch(s) {
                  case 0x0:
                    return new SveSqrdmlahIdx<int64_t>(
                            machInst, zda, zn, zm_64, imm_64);
                  case 0x1:
                    return new SveSqrdmlshIdx<int64_t>(
                            machInst, zda, zn, zm_64, imm_64);
                }
            }
            break;
        }
        return new Unknown64(machInst);
    } // decodeSve2SatMulAddHighIndexed

    // C4.1.68.4 SVE mixed sign dot product (indexed)
    StaticInstPtr
    decodeSveMixedSignDotProdIndexed(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
        uint8_t usig = (uint8_t) bits(machInst, 10);
        uint8_t i2 = (uint8_t) bits(machInst, 20, 19);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (size == 0x2) {
            if (usig) {
                return new SveSudoti<int8_t, uint8_t, int32_t>(
                        machInst, zda, zn, zm, i2);
            } else {
                return new SveUsdoti<uint8_t, int8_t, int32_t>(
                        machInst, zda, zn, zm, i2);
            }
        }
        return new Unknown64(machInst);
    } // decodeSveMixedSignDotProdIndexed

    // C4.1.68.5 SVE2 saturating multiply-add (indexed)
    StaticInstPtr
    decodeSve2SatMulAddIndexed(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t size = bits(machInst, 23, 22);

        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
        uint64_t imm = (bits(machInst, 20, 19) << 1) | bits(machInst, 11);
        if (size == 3) {
            zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
            imm = (bits(machInst, 20) << 1) | bits(machInst, 11);
        }

        uint8_t s_t = (bits(machInst, 12) << 1) | bits(machInst, 10);
        switch (s_t) {
          case 0x0: // S=0 T=0
            return decodeSveBinIdxUnpredSLong<SveSqdmlalbIdx>(
                    size, machInst, zd, zn, zm, imm);
          case 0x1: // S=0 T=1
            return decodeSveBinIdxUnpredSLong<SveSqdmlaltIdx>(
                    size, machInst, zd, zn, zm, imm);
          case 0x2: // S=1 T=0
            return decodeSveBinIdxUnpredSLong<SveSqdmlslbIdx>(
                    size, machInst, zd, zn, zm, imm);
          case 0x3: // S=1 T=1
            return decodeSveBinIdxUnpredSLong<SveSqdmlsltIdx>(
                    size, machInst, zd, zn, zm, imm);
        }
        return new Unknown64(machInst);
    } // decodeSve2SatMulAddIndexed

    // C4.1.68.6 SVE2 complex integer dot product (indexed)
    StaticInstPtr
    decodeSve2CplxIntDotProdIndexed(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t rot = bits(machInst, 11, 10);
        uint8_t size = bits(machInst, 23, 22);

        if (size == 2) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
            uint8_t imm = bits(machInst, 20, 19);
            return new SveCdoti<int8_t, int8_t, int32_t>(
                    machInst, zda, zn, zm, rot, imm);
        } else if (size == 3) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
            uint8_t imm = bits(machInst, 20);
            return new SveCdoti<int16_t, int16_t, int64_t>(
                    machInst, zda, zn, zm, rot, imm);
        }
        return new Unknown64(machInst);
    } // decodeSve2CplxIntDotProdIndexed

    // C4.1.68.7 SVE2 complex integer multiply-add (indexed)
    StaticInstPtr
    decodeSve2CplxIntMulAddIndexed(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t rot = bits(machInst, 11, 10);
        uint8_t size = bits(machInst, 23, 22);

        if (size == 2) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
            uint8_t imm = bits(machInst, 20, 19);
            return new SveCmlai<int16_t>(machInst, zda, zn, zm, rot, imm);
        } else if (size == 3) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
            uint8_t imm = bits(machInst, 20);
            return new SveCmlai<int32_t>(machInst, zda, zn, zm, rot, imm);
        }
        return new Unknown64(machInst);
    } // decodeSve2CplxIntMulAddIndexed

    // C4.1.68.8 SVE2 complex saturating multiply-add (indexed)
    StaticInstPtr
    decodeSve2CplxSatMulAddIndexed(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t rot = bits(machInst, 11, 10);
        uint8_t size = bits(machInst, 23, 22);

        if (size == 2) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
            uint8_t imm = bits(machInst, 20, 19);
            return new SveSqrdcmlahi<int16_t>(machInst, zda, zn, zm, rot, imm);
        } else if (size == 3) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
            uint8_t imm = bits(machInst, 20);
            return new SveSqrdcmlahi<int32_t>(machInst, zda, zn, zm, rot, imm);
        }
        return new Unknown64(machInst);
    } // decodeSve2CplxSatMulAddIndexed

    // C4.1.68.9 SVE2 integer multiply-add long (indexed)
    StaticInstPtr
    decodeSve2IntMulAddLongIndex(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t size = bits(machInst, 23, 22);

        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
        uint64_t imm = (bits(machInst, 20, 19) << 1) | bits(machInst, 11);
        if (size == 3) {
            zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
            imm = (bits(machInst, 20) << 1) | bits(machInst, 11);
        }

        uint8_t s_u_t = (bits(machInst, 13, 12) << 1) | bits(machInst, 10);
        switch (s_u_t) {
          case 0x0: // S=0 U=0 T=0
            return decodeSveBinIdxUnpredSLong<SveSmlalbIdx>(
                    size, machInst, zd, zn, zm, imm);
          case 0x1: // S=0 U=0 T=1
            return decodeSveBinIdxUnpredSLong<SveSmlaltIdx>(
                    size, machInst, zd, zn, zm, imm);
          case 0x2: // S=0 U=1 T=0
            return decodeSveBinIdxUnpredULong<SveUmlalbIdx>(
                    size, machInst, zd, zn, zm, imm);
          case 0x3: // S=0 U=1 T=1
            return decodeSveBinIdxUnpredULong<SveUmlaltIdx>(
                    size, machInst, zd, zn, zm, imm);
          case 0x4: // S=1 U=0 T=0
            return decodeSveBinIdxUnpredSLong<SveSmlslbIdx>(
                    size, machInst, zd, zn, zm, imm);
          case 0x5: // S=1 U=0 T=1
            return decodeSveBinIdxUnpredSLong<SveSmlsltIdx>(
                    size, machInst, zd, zn, zm, imm);
          case 0x6: // S=1 U=1 T=0
            return decodeSveBinIdxUnpredULong<SveUmlslbIdx>(
                    size, machInst, zd, zn, zm, imm);
          case 0x7: // S=1 U=1 T=1
            return decodeSveBinIdxUnpredULong<SveUmlsltIdx>(
                    size, machInst, zd, zn, zm, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntMulAddLongIndex

    // C4.1.68.10 SVE2 integer multiply long (indexed)
    StaticInstPtr
    decodeSve2IntMulLongIndex(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t u_t = (bits(machInst, 12) << 1) | bits(machInst, 10);
        uint8_t size = bits(machInst, 23, 22);

        if (size == 2) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
            uint64_t imm = (bits(machInst, 20, 19) << 1) | bits(machInst, 11);

            switch (u_t) {
              case 0x0: // U=0 T=0
                return new SveSmullbIdx<int16_t>(machInst, zd, zn, zm, imm);
              case 0x1: // U=0 T=1
                return new SveSmulltIdx<int16_t>(machInst, zd, zn, zm, imm);
              case 0x2: // U=1 T=0
                return new SveUmullbIdx<uint16_t>(machInst, zd, zn, zm, imm);
              case 0x3: // U=1 T=1
                return new SveUmulltIdx<uint16_t>(machInst, zd, zn, zm, imm);
            }
        } else if (size == 3) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
            uint64_t imm = (bits(machInst, 20) << 1) | bits(machInst, 11);

            switch (u_t) {
              case 0x0: // U=0 T=0
                return new SveSmullbIdx<int32_t>(machInst, zd, zn, zm, imm);
              case 0x1: // U=0 T=1
                return new SveSmulltIdx<int32_t>(machInst, zd, zn, zm, imm);
              case 0x2: // U=1 T=0
                return new SveUmullbIdx<uint32_t>(machInst, zd, zn, zm, imm);
              case 0x3: // U=1 T=1
                return new SveUmulltIdx<uint32_t>(machInst, zd, zn, zm, imm);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntMulLongIndex

    // C4.1.68.11 SVE2 saturating multiply (indexed)
    StaticInstPtr
    decodeSve2SatMulIndexed(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t t = (uint8_t) bits(machInst, 10);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (size == 0x2) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
            uint8_t idx = (bits(machInst, 20, 19) << 1) | bits(machInst, 11);
            if (t == 0) {
                return new SveSqdmullbIdx<int16_t>(machInst, zd, zn, zm, idx);
            } else {
                return new SveSqdmulltIdx<int16_t>(machInst, zd, zn, zm, idx);
            }
        } else if (size == 0x3) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
            uint8_t idx = (bits(machInst, 20) << 1) | bits(machInst, 11);
            if (t == 0) {
                return new SveSqdmullbIdx<int32_t>(machInst, zd, zn, zm, idx);
            } else {
                return new SveSqdmulltIdx<int32_t>(machInst, zd, zn, zm, idx);
            }
        }
        return new Unknown64(machInst);
    } // decodeSve2SatMulIndexed

    // C4.1.68.12 SVE2 saturating multiply high (indexed)
    StaticInstPtr
    decodeSve2SatMulHighIndexed(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t r = (uint8_t) bits(machInst, 10);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (size <= 0x1) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
            uint8_t idx = (bits(machInst, 22) << 2) | bits(machInst, 20, 19);
            if (r == 0) {
                return new SveSqdmulhIdx<int16_t>(machInst, zd, zn, zm, idx);
            } else {
                return new SveSqrdmulhIdx<int16_t>(machInst, zd, zn, zm, idx);
            }
        } else if (size == 0x2) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
            uint8_t idx = bits(machInst, 20, 19);
            if (r == 0) {
                return new SveSqdmulhIdx<int32_t>(machInst, zd, zn, zm, idx);
            } else {
                return new SveSqrdmulhIdx<int32_t>(machInst, zd, zn, zm, idx);
            }
        } else {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
            uint8_t idx = bits(machInst, 20);
            if (r == 0) {
                return new SveSqdmulhIdx<int64_t>(machInst, zd, zn, zm, idx);
            } else {
                return new SveSqrdmulhIdx<int64_t>(machInst, zd, zn, zm, idx);
            }
        }
        return new Unknown64(machInst);
    } // decodeSve2SatMulHighIndexed

    // C4.1.68.13 SVE2 integer multiply (indexed)
    StaticInstPtr
    decodeSve2IntMulIndexed(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (size <= 0x1) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
            uint8_t idx = (bits(machInst, 22) << 2) | bits(machInst, 20, 19);
            return new SveMulIdx<uint16_t>(machInst, zd, zn, zm, idx);
        } else if (size == 0x2) {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
            uint8_t idx = bits(machInst, 20, 19);
            return new SveMulIdx<uint32_t>(machInst, zd, zn, zm, idx);
        } else {
            RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
            uint8_t idx = bits(machInst, 20);
            return new SveMulIdx<uint64_t>(machInst, zd, zn, zm, idx);
        }
        return new Unknown64(machInst);
    } // decodeSve2SatMulHighIndexed

    // C4.1.68 SVE Multiply - Indexed
    StaticInstPtr
    decodeSveMulIdx(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 15, 10);
        switch (bits(op0, 5, 3)) {
          case 0x0: // op0=000xxx
            switch (bits(op0, 2, 1)) {
              case 0x0: // op0=00000x
                return decodeSveIntDotProdIndexed(machInst);
              case 0x1: // op0=00001x
                return decodeSve2IntMulAddIndexed(machInst);
              case 0x2: // op0=00010x
                return decodeSve2SatMulAddHighIndexed(machInst);
              case 0x3: // op0=00011x
                return decodeSveMixedSignDotProdIndexed(machInst);
            }
            break;
          case 0x1: // op0=001xxx
            return decodeSve2SatMulAddIndexed(machInst);
          case 0x2: // op0=010xxx
            if (bits(op0, 2) == 0) {  // op0=0100xx
                return decodeSve2CplxIntDotProdIndexed(machInst);
            }
            break;
          case 0x3: // op0=011xxx
            if (bits(op0, 2) == 0) {  // op0=0110xx
                return decodeSve2CplxIntMulAddIndexed(machInst);
            } else {  // op0=0111xx
                return decodeSve2CplxSatMulAddIndexed(machInst);
            }
          case 0x4: case 0x5: // op0=10xxxx
            return decodeSve2IntMulAddLongIndex(machInst);
          case 0x6: // op0=110xxx
            return decodeSve2IntMulLongIndex(machInst);
          case 0x7: // op0=111xxx
            if (bits(machInst, 12) == 0) {  // op0=1110xx
                return decodeSve2SatMulIndexed(machInst);
            } else if (bits(machInst, 11) == 0) { // op0=11110x
                return decodeSve2SatMulHighIndexed(machInst);
            } else if (bits(machInst, 10) == 0) { // op0=111110
                return decodeSve2IntMulIndexed(machInst);
            }
            break;
        }
        return new Unknown64(machInst);
    }

    // C4.1.69.1 SVE2 integer add/subtract long
    StaticInstPtr
    decodeSve2IntAddSubLong(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t op_s_u_t = bits(machInst, 13, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (op_s_u_t) {
          case 0x0: // op=0 S=0 U=0 T=0
            return decodeSveBinUnpredUnequalS<SveSaddlb>(
                    size, machInst, zd, zn, zm);
          case 0x1: // op=0 S=0 U=0 T=1
            return decodeSveBinUnpredUnequalS<SveSaddlt>(
                    size, machInst, zd, zn, zm);
          case 0x2: // op=0 S=0 U=1 T=0
            return decodeSveBinUnpredUnequalU<SveUaddlb>(
                    size, machInst, zd, zn, zm);
          case 0x3: // op=0 S=0 U=1 T=1
            return decodeSveBinUnpredUnequalU<SveUaddlt>(
                    size, machInst, zd, zn, zm);
          case 0x4: // op=0 S=1 U=0 T=0
            return decodeSveBinUnpredUnequalS<SveSsublb>(
                    size, machInst, zd, zn, zm);
          case 0x5: // op=0 S=1 U=0 T=1
            return decodeSveBinUnpredUnequalS<SveSsublt>(
                    size, machInst, zd, zn, zm);
          case 0x6: // op=0 S=1 U=1 T=0
            return decodeSveBinUnpredUnequalU<SveUsublb>(
                    size, machInst, zd, zn, zm);
          case 0x7: // op=0 S=1 U=1 T=1
            return decodeSveBinUnpredUnequalU<SveUsublt>(
                    size, machInst, zd, zn, zm);
          case 0xc: // op=1 S=1 U=0 T=0
            return decodeSveBinUnpredUnequalS<SveSabdlb>(
                    size, machInst, zd, zn, zm);
          case 0xd: // op=1 S=1 U=0 T=1
            return decodeSveBinUnpredUnequalS<SveSabdlt>(
                    size, machInst, zd, zn, zm);
          case 0xe: // op=1 S=1 U=1 T=0
            return decodeSveBinUnpredUnequalU<SveUabdlb>(
                    size, machInst, zd, zn, zm);
          case 0xf: // op=1 S=1 U=1 T=1
            return decodeSveBinUnpredUnequalU<SveUabdlt>(
                    size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntAddSubLong

    // C4.1.69.2 SVE2 integer add/subtract wide
    StaticInstPtr
    decodeSve2IntAddSubWide(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t s_u_t = bits(machInst, 12, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (s_u_t) {
            case 0x0: // S=0 U=0 T=0
              return decodeSveBinUnpredUnequalS<SveSaddwb>(
                      size, machInst, zd, zn, zm);
            case 0x1: // S=0 U=0 T=1
              return decodeSveBinUnpredUnequalS<SveSaddwt>(
                      size, machInst, zd, zn, zm);
            case 0x2: // S=0 U=1 T=0
              return decodeSveBinUnpredUnequalU<SveUaddwb>(
                      size, machInst, zd, zn, zm);
            case 0x3: // S=0 U=1 T=1
              return decodeSveBinUnpredUnequalU<SveUaddwt>(
                      size, machInst, zd, zn, zm);
            case 0x4: // S=1 U=0 T=0
              return decodeSveBinUnpredUnequalS<SveSsubwb>(
                      size, machInst, zd, zn, zm);
            case 0x5: // S=1 U=0 T=1
              return decodeSveBinUnpredUnequalS<SveSsubwt>(
                      size, machInst, zd, zn, zm);
            case 0x6: // S=1 U=1 T=0
              return decodeSveBinUnpredUnequalU<SveUsubwb>(
                      size, machInst, zd, zn, zm);
            case 0x7: // S=1 U=1 T=1
              return decodeSveBinUnpredUnequalU<SveUsubwt>(
                      size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntAddSubWide

    // C4.1.69.3 SVE2 integer multiply long
    StaticInstPtr
    decodeSve2IntMulLong(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t opc_u_t = bits(machInst, 12, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc_u_t) {
          case 0x0:   // op=0 U=0 T=0
            return decodeSveBinUnpredUnequalS<SveSqdmullb>(
                    size, machInst, zd, zn, zm);
          case 0x1:   // op=0 U=0 T=1
            return decodeSveBinUnpredUnequalS<SveSqdmullt>(
                    size, machInst, zd, zn, zm);
          case 0x2:   // op=0 U=1 T=0
            return decodeSveBinUnpredS2<SvePmullb, SvePmullb128>(
                    size, machInst, zd, zn, zm);
          case 0x3:   // op=0 U=1 T=1
            return decodeSveBinUnpredS2<SvePmullt, SvePmullt128>(
                    size, machInst, zd, zn, zm);
          case 0x4:   // op=1 U=0 T=0
            return decodeSveBinUnpredUnequalS<SveSmullb>(
                    size, machInst, zd, zn, zm);
          case 0x5:   // op=1 U=0 T=1
            return decodeSveBinUnpredUnequalS<SveSmullt>(
                    size, machInst, zd, zn, zm);
          case 0x6:   // op=1 U=1 T=0
            return decodeSveBinUnpredUnequalU<SveUmullb>(
                    size, machInst, zd, zn, zm);
          case 0x7:   // op=1 U=1 T=1
            return decodeSveBinUnpredUnequalU<SveUmullt>(
                    size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntMulLong

    // C4.1.69 SVE2 Widening Integer Arithmetic
    StaticInstPtr
    decodeSve2WideIntArith(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 14, 13);
        switch (op0) {
          case 0x0: case 0x1: // op0=0x
            return decodeSve2IntAddSubLong(machInst);
          case 0x2:           // op0=10
            return decodeSve2IntAddSubWide(machInst);
          case 0x3:           // op0=11
            return decodeSve2IntMulLong(machInst);
        }
        return new Unknown64(machInst);
    }

    // C4.1.70.1 SVE2 bitwise shift left long
    StaticInstPtr
    decodeSve2BitwiseShiftLeftLong(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t u_t = bits(machInst, 11, 10);
        uint8_t imm3 = (uint8_t) bits(machInst, 18, 16);
        uint8_t tsize = (bits(machInst, 22) << 2) | bits(machInst, 20, 19);

        uint8_t esize = 0;
        uint8_t size = 0;
        if (tsize == 0x0) {
            return new Unknown64(machInst);
        } else {
            decodeSveImmElemSize(tsize, &esize, &size);
        }

        unsigned shiftAmt = decodeSveImmLeftShiftAmt(tsize, esize, imm3);
        switch (u_t) {
          case 0x0: // U=0, T=0
            return decodeSveBinImmUnpredSigned<SveSshllb>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x1: // U=0, T=1
            return decodeSveBinImmUnpredSigned<SveSshllt>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x2: // U=1, T=0
            return decodeSveBinImmUnpredUnsigned<SveUshllb>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x3: // U=1, T=1
            return decodeSveBinImmUnpredUnsigned<SveUshllt>(
                    size, machInst, zd, zn, shiftAmt);
        }
        return new Unknown64(machInst);
    } // decodeSve2BitwiseShiftLeftLong

    // C4.1.70.2 SVE2 integer add/subtract interleaved long
    StaticInstPtr
    decodeSve2IntAddSubInterLong(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t s_tb = bits(machInst, 11, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (s_tb) {
          case 0x0: // S=0 tb=0
            return decodeSveBinUnpredUnequalS<SveSaddlbt>(
                    size, machInst, zd, zn, zm);
          case 0x2: // S=1 tb=0
            return decodeSveBinUnpredUnequalS<SveSsublbt>(
                    size, machInst, zd, zn, zm);
          case 0x3: // S=1 tb=1
            return decodeSveBinUnpredUnequalS<SveSsubltb>(
                    size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntAddSubInterLong

    // C4.1.70.3 SVE2 bitwise exclusive-or interleaved
    StaticInstPtr
    decodeSve2BitwiseEorInterleaved(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t tb = bits(machInst, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (tb) {
          case 0x0:   // tb=0
            return decodeSveBinUnpredU<SveEorbt>(size, machInst, zd, zn, zm);
          case 0x1:   // tb=1
            return decodeSveBinUnpredU<SveEortb>(size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2BitwiseEorInterleaved

    // C4.1.70.4 SVE integer matrix multiply accumulate
    StaticInstPtr
    decodeSveIntMatMulAdd(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t uns = bits(machInst, 23, 22);

        switch (uns) {
          case 0x0:   // uns=00
            return new SveSmmla<int32_t, int8_t, int8_t>(
                    machInst, zda, zn, zm);
          case 0x2:   // uns=10
            return new SveUsmmla<int32_t, uint8_t, int8_t>(
                    machInst, zda, zn, zm);
          case 0x3:   // uns=11
            return new SveUmmla<uint32_t, uint8_t, uint8_t>(
                    machInst, zda, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntMatMulAdd

    // C4.1.70.5 SVE2 bitwise permute
    StaticInstPtr
    decodeSve2BitPerm(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t opc = bits(machInst, 11, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:
            return decodeSveBinUnpredU<SveBext>(size, machInst, zd, zn, zm);
          case 0x1:
            return decodeSveBinUnpredU<SveBdep>(size, machInst, zd, zn, zm);
          case 0x2:
            return decodeSveBinUnpredU<SveBgrp>(size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2BitPerm

    // C4.1.70 SVE Misc
    StaticInstPtr
    decodeSveMisc(ExtMachInst machInst)
    {
        uint8_t op1_13_12 = bits(machInst, 13, 12);
        switch(op1_13_12) {
          case 0x0:   // op1=00xx
            return decodeSve2IntAddSubInterLong(machInst);
          case 0x1:   // op1=01xx
            {
                uint8_t op1 = bits(machInst, 13, 10);
                if (bits(op1, 1) == 0) {  // op1=010x
                    return decodeSve2BitwiseEorInterleaved(machInst);
                } else if (bits(op1, 0) == 0) {   // op1=0110
                    return decodeSveIntMatMulAdd(machInst);
                }
            }
            break;
          case 0x2:   // op1=10xx
            {
                uint8_t op0 = bits(machInst, 23);
                if (op0 == 0) {
                    return decodeSve2BitwiseShiftLeftLong(machInst);
                }
            }
            break;
          case 0x3:   // op1=11xx
            return decodeSve2BitPerm(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveMisc

    // C4.1.71.1 SVE2 complex integer add
    StaticInstPtr
    decodeSve2CplxIntAdd(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t rot = bits(machInst, 10) << 1 | 0x01;
        uint8_t op = bits(machInst, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (op == 0) {
            switch (size) {
              case 0:
                return new SveCadd<int8_t>(machInst, zdn, zdn, zm, rot);
              case 1:
                return new SveCadd<int16_t>(machInst, zdn, zdn, zm, rot);
              case 2:
                return new SveCadd<int32_t>(machInst, zdn, zdn, zm, rot);
              case 3:
                return new SveCadd<int64_t>(machInst, zdn, zdn, zm, rot);
            }
        } else {
            switch (size) {
              case 0:
                return new SveSqcadd<int8_t>(machInst, zdn, zdn, zm, rot);
              case 1:
                return new SveSqcadd<int16_t>(machInst, zdn, zdn, zm, rot);
              case 2:
                return new SveSqcadd<int32_t>(machInst, zdn, zdn, zm, rot);
              case 3:
                return new SveSqcadd<int64_t>(machInst, zdn, zdn, zm, rot);
            }
        }
        return new Unknown64(machInst);
    } // decodeSve2CplxIntAdd

    // C4.1.71.2 SVE2 integer absolute difference and accumulate long
    StaticInstPtr
    decodeSve2IntAbsDiffAccLong(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t u_t = bits(machInst, 11, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (u_t) {
          case 0x0: // U=0 T=0
            return decodeSveBinUnpredUnequalS<SveSabalb>(
                    size, machInst, zd, zn, zm);
          case 0x1: // U=0 T=1
            return decodeSveBinUnpredUnequalS<SveSabalt>(
                    size, machInst, zd, zn, zm);
          case 0x2: // U=1 T=0
            return decodeSveBinUnpredUnequalU<SveUabalb>(
                    size, machInst, zd, zn, zm);
          case 0x3: // U=1 T=1
            return decodeSveBinUnpredUnequalU<SveUabalt>(
                    size, machInst, zd, zn, zm);
        }

        return new Unknown64(machInst);
    }  // decodeSve2IntAbsDiffAccLong

    // C4.1.71.3 SVE2 integer add/subtract long with carry
    StaticInstPtr
    decodeSve2IntAddSubLongCarry(ExtMachInst machInst)
    {
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        uint8_t t = bits(machInst, 10);
        uint8_t size = bits(machInst, 23, 22);

        if (bits(size, 1) == 0) {
            if (t){
                return decodeSveTerUnpred<Sve2Adclt>(
                        size, machInst, zda, zn, zm);
            } else {
                return decodeSveTerUnpred<Sve2Adclb>(
                        size, machInst, zda, zn, zm);
            }
        } else {
            if (t){
                return decodeSveTerUnpred<Sve2Sbclt>(
                        size, machInst, zda, zn, zm);
            } else {
                return decodeSveTerUnpred<Sve2Sbclb>(
                        size, machInst, zda, zn, zm);
            }
        }
        return new Unknown64(machInst);
    } // decodeSve2IntAddSubLongCarry

    // C4.1.71.4 SVE2 bitwise shift right and accumulate
    StaticInstPtr
    decodeSve2BitwiseShiftRightAndAcc(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t r_u = bits(machInst, 11, 10);
        uint8_t imm3 = (uint8_t) bits(machInst, 18, 16);
        uint8_t tsize = (bits(machInst, 23, 22) << 2) | bits(machInst, 20, 19);

        uint8_t esize = 0;
        uint8_t size = 0;
        if (tsize == 0x0) {
            return new Unknown64(machInst);
        } else {
            decodeSveImmElemSize(tsize, &esize, &size);
        }

        unsigned shiftAmt = decodeSveImmRightShiftAmt(tsize, esize, imm3);
        switch (r_u) {
          case 0x0: // R=0 U=0
            return decodeSveBinImmUnpredS<SveSsra>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x1: // R=0 U=1
            return decodeSveBinImmUnpredU<SveUsra>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x2: // R=1 U=0
            return decodeSveBinImmUnpredS<SveSrsra>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x3: // R=1 U=1
            return decodeSveBinImmUnpredU<SveUrsra>(
                    size, machInst, zd, zn, shiftAmt);
        }
        return new Unknown64(machInst);
    }  // decodeSve2BitwiseShiftRightAndAcc

    // C4.1.71.5 SVE2 bitwise shift and insert
    StaticInstPtr
    decodeSve2BitwiseShiftAndInsert(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t op = bits(machInst, 10);
        uint8_t imm3 = (uint8_t) bits(machInst, 18, 16);
        uint8_t tsize = (bits(machInst, 23, 22) << 2) | bits(machInst, 20, 19);

        uint8_t esize = 0;
        uint8_t size = 0;
        if (tsize == 0x0) {
            return new Unknown64(machInst);
        } else {
            decodeSveImmElemSize(tsize, &esize, &size);
        }

        switch (op) {
          case 0x0: // op=0
            return decodeSveBinImmUnpredU<SveSri>(size, machInst, zd, zn,
                    decodeSveImmRightShiftAmt(tsize, esize, imm3));
          case 0x1: // op=1
            return decodeSveBinImmUnpredU<SveSli>(size, machInst, zd, zn,
                    decodeSveImmLeftShiftAmt(tsize, esize, imm3));
        }
        return new Unknown64(machInst);
    } // decodeSve2BitwiseShiftAndInsert

    // C4.1.71.6 SVE2 integer absolute difference and accumulate
    StaticInstPtr
    decodeSve2IntAbsDiffAndAcc(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t op = bits(machInst, 10);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (op) {
          case 0x0: // U=0
            return decodeSveBinUnpredS<SveSaba>(size, machInst, zda, zn, zm);
          case 0x1: // U=1
            return decodeSveBinUnpredU<SveUaba>(size, machInst, zda, zn, zm);
        }
        return new Unknown64(machInst);
    } // decodeSve2IntAbsDiffAndAcc

    // C4.1.71 SVE2 Accumulate
    StaticInstPtr
    decodeSve2Accum(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 20, 17);
        uint8_t op1 = bits(machInst, 13, 11);
        switch (op1) {
          case 0x0: case 0x1: // op1=00x
            return decodeSve2IntAbsDiffAccLong(machInst);
          case 0x2:           // op1=010
            return decodeSve2IntAddSubLongCarry(machInst);
          case 0x3:           // op1=011
            if (op0 == 0) {   // op0=0000 op1=011
                return decodeSve2CplxIntAdd(machInst);
            }
            break;
          case 0x4: case 0x5: // op1=10x
            return decodeSve2BitwiseShiftRightAndAcc(machInst);
          case 0x6:           // op1=110
            return decodeSve2BitwiseShiftAndInsert(machInst);
          case 0x7:           // op1=111
            return decodeSve2IntAbsDiffAndAcc(machInst);
        }
        return new Unknown64(machInst);
    } // decodeSve2Accum

    // C4.1.72.1 SVE2 saturating extract narrow
    StaticInstPtr
    decodeSve2SatExtNarrow(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t opc_t = bits(machInst, 12, 10);
        uint8_t tsize = (bits(machInst, 22) << 2) | bits(machInst, 20, 19);

        uint8_t esize = 0;
        uint8_t size = 0;
        if (tsize == 0x0) {
            return new Unknown64(machInst);
        } else {
            decodeSveImmElemSize(tsize, &esize, &size);
        }

        switch (opc_t) {
          case 0x0: // opc=00 T=0
            return decodeSveUnaryUnpredNarrowS<SveSqxtnb>(
                    size, machInst, zd, zn);
          case 0x1: // opc=00 T=1
            return decodeSveUnaryUnpredNarrowS<SveSqxtnt>(
                    size, machInst, zd, zn);
          case 0x2: // opc=01 T=0
            return decodeSveUnaryUnpredNarrowU<SveUqxtnb>(
                    size, machInst, zd, zn);
          case 0x3: // opc=01 T=1
            return decodeSveUnaryUnpredNarrowU<SveUqxtnt>(
                    size, machInst, zd, zn);
          case 0x4: // opc=10 T=0
            return decodeSveUnaryUnpredNarrowS<SveSqxtunb>(
                    size, machInst, zd, zn);
          case 0x5: // opc=10 T=1
            return decodeSveUnaryUnpredNarrowS<SveSqxtunt>(
                    size, machInst, zd, zn);
        }
        return new Unknown64(machInst);
    }  // decodeSve2BitwiseShiftNarrow

    // C4.1.72.2 SME2 multi-vec extract narrow
    StaticInstPtr
    decodeSme2MulvecExtNarrow(ExtMachInst machInst)
    {
        uint8_t tsize = (bits(machInst, 22) << 2) | bits(machInst, 20, 19);
        if (tsize != 0x2) {
            return new Unknown64(machInst);
        }

        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) ((uint8_t) bits(machInst, 9, 6) << 1);
        uint8_t opc = bits(machInst, 12, 11);

        switch (opc) {
          case 0x0: // opc=00
            return new SveSqcvtn<int16_t>(machInst, zd, zn, zn + 1);
          case 0x1: // opc=01
            return new SveUqcvtn<uint16_t>(machInst, zd, zn, zn + 1);
          case 0x2: // opc=10
            return new SveSqcvtun<int16_t>(machInst, zd, zn, zn + 1);
        }
        return new Unknown64(machInst);
    }  // decodeSme2MulvecExtNarrow

    // C4.1.72.3 SVE2 bitwise shift right narrow
    StaticInstPtr
    decodeSve2BitwiseShiftNarrow(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t opc_u_r_t = bits(machInst, 13, 10);
        uint8_t imm3 = (uint8_t) bits(machInst, 18, 16);
        uint8_t tsize = (bits(machInst, 22) << 2) | bits(machInst, 20, 19);

        uint8_t esize = 0;
        uint8_t size = 0;
        if (tsize == 0x0) {
            return new Unknown64(machInst);
        } else {
            decodeSveImmElemSize(tsize, &esize, &size);
        }

        unsigned shiftAmt = decodeSveImmRightShiftAmt(tsize, esize, imm3);
        switch (opc_u_r_t) {
          case 0x0: // op=0 U=0 R=0 T=0
            return decodeSveBinImmUnpredNarrowS<SveSqshrunb>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x1: // op=0 U=0 R=0 T=1
            return decodeSveBinImmUnpredNarrowS<SveSqshrunt>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x2: // op=0 U=0 R=1 T=0
            return decodeSveBinImmUnpredNarrowS<SveSqrshrunb>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x3: // op=0 U=0 R=1 T=1
            return decodeSveBinImmUnpredNarrowS<SveSqrshrunt>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x4: // op=0 U=1 R=0 T=0
            return decodeSveBinImmUnpredNarrowU<SveShrnb>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x5: // op=0 U=1 R=0 T=1
            return decodeSveBinImmUnpredNarrowU<SveShrnt>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x6: // op=0 U=1 R=1 T=0
            return decodeSveBinImmUnpredNarrowU<SveRshrnb>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x7: // op=0 U=1 R=1 T=1
            return decodeSveBinImmUnpredNarrowU<SveRshrnt>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x8: // op=1 U=0 R=0 T=0
            return decodeSveBinImmUnpredNarrowS<SveSqshrnb>(
                    size, machInst, zd, zn, shiftAmt);
          case 0x9: // op=1 U=0 R=0 T=1
            return decodeSveBinImmUnpredNarrowS<SveSqshrnt>(
                    size, machInst, zd, zn, shiftAmt);
          case 0xa: // op=1 U=0 R=1 T=0
            return decodeSveBinImmUnpredNarrowS<SveSqrshrnb>(
                    size, machInst, zd, zn, shiftAmt);
          case 0xb: // op=1 U=0 R=1 T=1
            return decodeSveBinImmUnpredNarrowS<SveSqrshrnt>(
                    size, machInst, zd, zn, shiftAmt);
          case 0xc: // op=1 U=1 R=0 T=0
            return decodeSveBinImmUnpredNarrowU<SveUqshrnb>(
                    size, machInst, zd, zn, shiftAmt);
          case 0xd: // op=1 U=1 R=0 T=1
            return decodeSveBinImmUnpredNarrowU<SveUqshrnt>(
                    size, machInst, zd, zn, shiftAmt);
          case 0xe: // op=1 U=1 R=1 T=0
            return decodeSveBinImmUnpredNarrowU<SveUqrshrnb>(
                    size, machInst, zd, zn, shiftAmt);
          case 0xf: // op=1 U=1 R=1 T=1
            return decodeSveBinImmUnpredNarrowU<SveUqrshrnt>(
                    size, machInst, zd, zn, shiftAmt);
        }
        return new Unknown64(machInst);
    }  // decodeSve2BitwiseShiftNarrow

    // C4.1.72.4 SME2 multi-vec shift narrow
    StaticInstPtr
    decodeSme2MulvecShiftNarrow(ExtMachInst machInst)
    {
        uint8_t tsize = (bits(machInst, 22) << 1) | bits(machInst, 20);
        uint8_t r = bits(machInst, 11);
        if (tsize != 0x1 || r != 1) {
            return new Unknown64(machInst);
        }

        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) ((uint8_t) bits(machInst, 9, 6) << 1);
        uint8_t op_u = bits(machInst, 13, 12);
        uint8_t imm4 = bits(machInst, 19, 16);

        unsigned esize = 16;
        unsigned shiftAmt = esize - imm4;
        switch (op_u) {
          case 0x0: // op=0 U=0
            return new SveSqrshrun<int16_t>(
                machInst, zd, zn, zn + 1, shiftAmt);
          case 0x2: // op=1 U=0
            return new SveSqrshrn<int16_t>(
                machInst, zd, zn, zn + 1, shiftAmt);
          case 0x3: // op=1 U=1
            return new SveUqrshrn<uint16_t>(
                machInst, zd, zn, zn + 1, shiftAmt);
        }
        return new Unknown64(machInst);
    }  // decodeSme2MulvecShiftNarrow

    // C4.1.72.5 SVE2 integer add/subtract narrow high part
    StaticInstPtr
    decodeSve2IntAddSubNarrowHigh(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t s_r_t = bits(machInst, 12, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (s_r_t) {
          case 0x0:
            return decodeSveBinUnpredUnequalU<SveAddhnb>(
                    size, machInst, zd, zn, zm);
          case 0x1:
            return decodeSveBinUnpredUnequalU<SveAddhnt>(
                    size, machInst, zd, zn, zm);
          case 0x2:
            return decodeSveBinUnpredUnequalU<SveRaddhnb>(
                    size, machInst, zd, zn, zm);
          case 0x3:
            return decodeSveBinUnpredUnequalU<SveRaddhnt>(
                    size, machInst, zd, zn, zm);
          case 0x4:
            return decodeSveBinUnpredUnequalU<SveSubhnb>(
                    size, machInst, zd, zn, zm);
          case 0x5:
            return decodeSveBinUnpredUnequalU<SveSubhnt>(
                    size, machInst, zd, zn, zm);
          case 0x6:
            return decodeSveBinUnpredUnequalU<SveRsubhnb>(
                    size, machInst, zd, zn, zm);
          case 0x7:
            return decodeSveBinUnpredUnequalU<SveRsubhnt>(
                    size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSve2IntAddSubNarrowHigh

    // C4.1.72 SVE2 Narrowing
    StaticInstPtr
    decodeSve2Narrow(ExtMachInst machInst) {
        uint8_t op0_op3 = (bits(machInst, 23) << 2) | bits(machInst, 14, 13);
        uint8_t op1_op2 = bits(machInst, 18, 16);
        switch (op0_op3) {
          case 0x0: case 0x1: // op0=0 op3=0x
            return decodeSve2BitwiseShiftNarrow(machInst);
          case 0x2: // op0=0 op3=10
            if (op1_op2 == 0) {  // op0=0 op1=00 op2=0 op3=10
                return decodeSve2SatExtNarrow(machInst);
            } else if (op1_op2 == 1) {
                uint8_t op4 = bits(machInst, 10);
                uint8_t op5 = bits(machInst, 5);
                if (op4 == 0 && op5 == 0) {
                    // op0=0 op1=00 op2=1 op3=10 op4=0 op5=0
                    // SME2 multi-vec extract narrow
                    return decodeSme2MulvecExtNarrow(machInst);
                }
            }
            break;
          case 0x3: case 0x7: // op3=11
            return decodeSve2IntAddSubNarrowHigh(machInst);
          case 0x4: case 0x5: // op0=1 op3=0x
            {
                uint8_t op4 = bits(machInst, 10);
                uint8_t op5 = bits(machInst, 5);
                if (op4 == 0 && op5 == 0) {
                    // op0=1, op3=0x op4=0 op5=0
                    // SME2 multi-vec shift narrow
                    return decodeSme2MulvecShiftNarrow(machInst);
                }
            }
            break;
        }

        return new Unknown64(machInst);
    }

    // C4.1.73 SVE2 Histogram Computation (Segment) and Lookup Table
    StaticInstPtr
    decodeHistCompSegAndLut(ExtMachInst machInst) {
        switch (bits(machInst, 12, 10)) {
          case 0x0: // op1=000
            {
                RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
                uint8_t size = bits(machInst, 23, 22);
                if (size != 0) {
                    return new Unknown64(machInst);
                }
                return new SveHistseg<uint8_t>(machInst, zd, zn, zm);
            }
            break;
          case 0x1: // op1=001
            if (bits(machInst, 22) == 1) {
                // LUTI4
                return new Unknown64(machInst);
            }
            break;
          case 0x2: case 0x6: // op1=x10
            // LUTI2 - Halfword
            break;
          case 0x4: // op1=100
            // LUTI2 - Byte
            break;
          case 0x5: case 0x7: // op1=1x1
            // SVE2 lookup table with 4-bit indices and 16-bit element size
            break;
        }
        return new Unknown64(machInst);
    }

    StaticInstPtr
    decodeSve2CryptBinConstr(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t size = bits(machInst, 23, 22);
        uint8_t opc = bits(machInst, 10);
        uint8_t size_opc = (size << 1) | opc;

        switch (size_opc) {
          case 0x1:
            return new SveRax1<uint64_t>(machInst, zd, zn, zm);
          case 0x0:
            // SM4EKEY
          default:
            return new Unknown64(machInst);
        }
    }  // decodeSve2CryptBinConstr

    // SVE2 Crypto Extensions
    StaticInstPtr
    decodeSve2Crypto(ExtMachInst machInst)
    {
        uint8_t op2 = bits(machInst, 12, 11);
        switch (op2) {
          case 0x2:
            return decodeSve2CryptBinConstr(machInst);
          default:
            return new Unknown64(machInst);
        }
    }

    // C4.1.76.1 SVE BFloat16 floating-point dot product (indexed)
    StaticInstPtr
    decodeSveBfDotProdIndexed(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t op = (bits(machInst, 22) << 2) | bits(machInst, 11, 10);

        switch (op) {
          case 0x0:
            return new SveFdotHpSpIdx<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn,
                (RegIndex) (uint8_t) bits(machInst, 18, 16),
                bits(machInst, 20, 19));
          case 0x4:
            return new SveBFdotIdx<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn,
                (RegIndex) (uint8_t) bits(machInst, 18, 16),
                bits(machInst, 20, 19));
        }
        return new Unknown64(machInst);
    } // decodeSveBfDotProdIndexed

    // C4.1.76.2 SVE floating-point multiply-add long (indexed)
    StaticInstPtr
    decodeSveFpMulAddLongIndexed(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
        uint8_t imm = (bits(machInst, 20, 19) << 1) | bits(machInst, 11);
        uint8_t o2_op_t = (bits(machInst, 22) << 2) |
                          (bits(machInst, 13) << 1) | bits(machInst, 10);

        switch (o2_op_t) {
          case 0x0:   // o2=0 op=0 T=0
            return new SveFmlalbIdx<uint16_t, uint16_t, uint32_t>(
                machInst, zda, zn, zm, imm);
          case 0x1:   // o2=0 op=0 T=1
            return new SveFmlaltIdx<uint16_t, uint16_t, uint32_t>(
                machInst, zda, zn, zm, imm);
          case 0x2:   // o2=0 op=1 T=0
            return new SveFmlslbIdx<uint16_t, uint16_t, uint32_t>(
                machInst, zda, zn, zm, imm);
          case 0x3:   // o2=0 op=1 T=1
            return new SveFmlsltIdx<uint16_t, uint16_t, uint32_t>(
                machInst, zda, zn, zm, imm);
          case 0x4:   // o2=1 op=0 T=0
            return new SveBFmlalbIdx<uint16_t, uint16_t, uint32_t>(
                machInst, zda, zn, zm, imm);
          case 0x5:   // o2=1 op=0 T=1
            return new SveBFmlaltIdx<uint16_t, uint16_t, uint32_t>(
                machInst, zda, zn, zm, imm);
          case 0x6:   // o2=1 op=1 T=0
            return new SveBFmlslbIdx<uint16_t, uint16_t, uint32_t>(
                machInst, zda, zn, zm, imm);
          case 0x7:   // o2=1 op=1 T=1
            return new SveBFmlsltIdx<uint16_t, uint16_t, uint32_t>(
                machInst, zda, zn, zm, imm);
        }
        return new Unknown64(machInst);
    } // decodeSveFpMulAddLongIndexed

    // C4.1.76 SVE floating-point widening multiply-add - indexed
    StaticInstPtr
    decodeSveFpWidenMulAddIndexed(ExtMachInst machInst)
    {
        uint8_t op0_op1 = (bits(machInst, 23) << 1) | bits(machInst, 13);
        switch (op0_op1) {
          case 0x0:           // op0=0 op1=0
            return decodeSveBfDotProdIndexed(machInst);
          case 0x2: case 0x3: // op1=1 op1=x
            return decodeSveFpMulAddLongIndexed(machInst);
        }
        return new Unknown64(machInst);
    } // decodeSveFpWidenMulAddIndexed

    // C4.1.77.1 SVE BFloat16 floating-point dot product
    StaticInstPtr
    decodeSveBfDotProd(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t op = (bits(machInst, 22) << 1) | bits(machInst, 10);

        switch (op) {
          case 0:
            return new SveFdotHpSp<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn,
                (RegIndex) (uint8_t) bits(machInst, 20, 16));
          case 2:
            return new SveBFdot<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn,
                (RegIndex) (uint8_t) bits(machInst, 20, 16));
        }
        return new Unknown64(machInst);
    } // decodeSveBfDotProd

    // C4.1.77.2 SVE floating-point multiply-add long
    StaticInstPtr
    decodeSveFpMulAddLong(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t o2_op_t = (bits(machInst, 22) << 2) |
                          (bits(machInst, 13) << 1) | bits(machInst, 10);

        switch (o2_op_t) {
          case 0x0:   // o2=0 op=0 T=0
            return new SveFmlalb<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn, zm);
          case 0x1:   // o2=0 op=0 T=1
            return new SveFmlalt<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn, zm);
          case 0x2:   // o2=0 op=1 T=0
            return new SveFmlslb<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn, zm);
          case 0x3:   // o2=0 op=1 T=1
            return new SveFmlslt<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn, zm);
          case 0x4:   // o2=1 op=0 T=0
            return new SveBFmlalb<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn, zm);
          case 0x5:   // o2=1 op=0 T=1
            return new SveBFmlalt<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn, zm);
          case 0x6:   // o2=1 op=1 T=0
            return new SveBFmlslb<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn, zm);
          case 0x7:   // o2=1 op=1 T=1
            return new SveBFmlslt<uint16_t, uint16_t, uint32_t>(
                machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    } // decodeSveFpMulAddLong

    // C4.1.77 SVE floating-point widening multiply-add
    StaticInstPtr
    decodeSveFpWidenMulAdd(ExtMachInst machInst)
    {
        uint8_t op0_op1 = (bits(machInst, 23) << 1) | bits(machInst, 13);
        switch (op0_op1) {
          case 0x0:           // op0=0 op1=0
            return decodeSveBfDotProd(machInst);
          case 0x2: case 0x3: // op1=1 op1=x
            return decodeSveFpMulAddLong(machInst);
        }
        return new Unknown64(machInst);
    } // decodeSveFpWidenMulAdd

    // C4.1.78.3 SVE floating-point reciprocal estimate (unpredicated)
    StaticInstPtr
    decodeSveFpRecipEstimateUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t op = (uint8_t) bits(machInst, 16);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (op) {
          case 0x0: // op=0
            return decodeSveUnaryUnpredF<SveFrecpe>(size, machInst, zd, zn);
          case 0x1: // op=1
            return decodeSveUnaryUnpredF<SveFrsqrte>(size, machInst, zd, zn);
        }
        return new Unknown64(machInst);
    } // decodeSveFpRecipEstimateUnpred

    // C4.1.78 SVE floating-point unary operations - unpredicated
    StaticInstPtr
    decodeSveFpUnaryOpUnpred(ExtMachInst machInst)
    {
        uint8_t op1 = bits(machInst, 18, 16);
        switch (op1) {
          case 0x6: case 0x7:
            if (bits(machInst, 11, 10) == 0x0) { // op1=11x op2=00
                return decodeSveFpRecipEstimateUnpred(machInst);
            }
            break;
        }
        return new Unknown64(machInst);
    } // decodeSveFpUnaryOpUnpred

    // C4.1.79 SVE floating-point compare - with zero
    StaticInstPtr
    decodeSveFpCmpZero(ExtMachInst machInst)
    {
        if (bits(machInst, 18) != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = (bits(machInst, 17, 16) << 1) | bits(machInst, 4);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // eq=0 lt=0 ne=0
            return decodeSveCmpImmF<SveFcmgeZero>(
                size, machInst, pd, zn, 0x0, pg);
          case 0x1:   // eq=0 lt=0 ne=1
            return decodeSveCmpImmF<SveFcmgtZero>(
                size, machInst, pd, zn, 0x0, pg);
          case 0x2:   // eq=0 lt=1 ne=0
            return decodeSveCmpImmF<SveFcmltZero>(
                size, machInst, pd, zn, 0x0, pg);
          case 0x3:   // eq=0 lt=1 ne=1
            return decodeSveCmpImmF<SveFcmleZero>(
                size, machInst, pd, zn, 0x0, pg);
          case 0x4:   // eq=1 lt=0 ne=0
            return decodeSveCmpImmF<SveFcmeqZero>(
                size, machInst, pd, zn, 0x0, pg);
          case 0x6:   // eq=1 lt=1 ne=0
            return decodeSveCmpImmF<SveFcmneZero>(
                size, machInst, pd, zn, 0x0, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpCmpZero

    // C4.1.80 SVE floating-point accumulating reduction
    StaticInstPtr
    decodeSveFpAccumReduc(ExtMachInst machInst)
    {
        if (bits(machInst, 18) != 0x0) {
            return new Unknown64(machInst);
        }

        RegIndex vdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 17, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (opc == 0x0) {
            return decodeSveUnaryPredF<SveFadda>(size, machInst, vdn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpAccumReduc

    // C4.1.81.1 SVE floating-point arithmetic (predicated)
    StaticInstPtr
    decodeSveFpAccumPredSub(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = (uint8_t) bits(machInst, 19, 16);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        if (size == 0) {
            switch (opc) {
              case 0x0:   // opc=0000
                return new SveBfaddPred<uint16_t>(machInst, zdn, zm, pg);
              case 0x1:   // opc=0001
                return new SveBfsubPred<uint16_t>(machInst, zdn, zm, pg);
              case 0x2:   // opc=0010
                return new SveBfmulPred<uint16_t>(machInst, zdn, zm, pg);
              case 0x4:   // opc=0100
                return new SveBfmaxnm<uint16_t>(machInst, zdn, zm, pg);
              case 0x5:   // opc=0101
                return new SveBfminnm<uint16_t>(machInst, zdn, zm, pg);
              case 0x6:   // opc=0110
                return new SveBfmax<uint16_t>(machInst, zdn, zm, pg);
              case 0x7:   // opc=0111
                return new SveBfmin<uint16_t>(machInst, zdn, zm, pg);
            }
        } else {
            switch (opc) {
              case 0x0:   // opc=0000
                return decodeSveBinDestrPredF<SveFaddPred>(
                        size, machInst, zdn, zm, pg);
              case 0x1:   // opc=0001
                return decodeSveBinDestrPredF<SveFsubPred>(
                        size, machInst, zdn, zm, pg);
              case 0x2:   // opc=0010
                return decodeSveBinDestrPredF<SveFmulPred>(
                        size, machInst, zdn, zm, pg);
              case 0x3:   // opc=0011
                return decodeSveBinDestrPredF<SveFsubr>(
                        size, machInst, zdn, zm, pg);
              case 0x4:   // opc=0100
                return decodeSveBinDestrPredF<SveFmaxnm>(
                        size, machInst, zdn, zm, pg);
              case 0x5:   // opc=0101
                return decodeSveBinDestrPredF<SveFminnm>(
                        size, machInst, zdn, zm, pg);
              case 0x6:   // opc=0110
                return decodeSveBinDestrPredF<SveFmax>(
                        size, machInst, zdn, zm, pg);
              case 0x7:   // opc=0111
                return decodeSveBinDestrPredF<SveFmin>(
                        size, machInst, zdn, zm, pg);
              case 0x8:   // opc=1000
                return decodeSveBinDestrPredF<SveFabd>(
                        size, machInst, zdn, zm, pg);
              case 0x9:   // opc=1001
                return decodeSveBinDestrPredF<SveFscale>(
                        size, machInst, zdn, zm, pg);
              case 0xa:   // opc=1010
                return decodeSveBinDestrPredF<SveFmulx>(
                        size, machInst, zdn, zm, pg);
              case 0xc:   // opc=1100
                return decodeSveBinDestrPredF<SveFdivr>(
                        size, machInst, zdn, zm, pg);
              case 0xd:   // opc=1101
                return decodeSveBinDestrPredF<SveFdiv>(
                        size, machInst, zdn, zm, pg);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveFpAccumPredSub

    // C4.1.81.2 SVE floating-point arithmetic with immediate (predicated)
    StaticInstPtr
    decodeSveFpArithImmPred(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint64_t imm;
        uint8_t opc = (uint8_t) bits(machInst, 18, 16);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=000
            imm = sveExpandFpImmAddSub((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFaddImm>(
                    size, machInst, zdn, imm, pg);
          case 0x1:   // opc=001
            imm = sveExpandFpImmAddSub((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFsubImm>(
                    size, machInst, zdn, imm, pg);
          case 0x2:   // opc=010
            imm = sveExpandFpImmMul((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFmulImm>(
                    size, machInst, zdn, imm, pg);
          case 0x3:   // opc=011
            imm = sveExpandFpImmAddSub((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFsubrImm>(
                    size, machInst, zdn, imm, pg);
          case 0x4:   // opc=100
            imm = sveExpandFpImmMaxMin((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFmaxnmImm>(
                    size, machInst, zdn, imm, pg);
          case 0x5:   // opc=101
            imm = sveExpandFpImmMaxMin((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFminnmImm>(
                    size, machInst, zdn, imm, pg);
          case 0x6:   // opc=110
            imm = sveExpandFpImmMaxMin((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFmaxImm>(
                    size, machInst, zdn, imm, pg);
          case 0x7:   // opc=111
            imm = sveExpandFpImmMaxMin((uint8_t) bits(machInst, 5), size);
            return decodeSveBinImmPredF<SveFminImm>(
                    size, machInst, zdn, imm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpArithImmPred

    // C4.1.81 SVE floating-point arithmetic - predicated
    StaticInstPtr
    decodeSveFpArithPred(ExtMachInst machInst)
    {
        if (bits(machInst, 20) == 0) {
            return decodeSveFpAccumPredSub(machInst);
        } else if (bits(machInst, 19) == 0) {
            if (bits(machInst, 12, 10) == 0) {
                // FTMAD
                RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
                uint8_t imm = (uint8_t) bits(machInst, 18, 16);
                uint8_t size = (uint8_t) bits(machInst, 23, 22);

                return decodeSveTerImmUnpredF<SveFtmad>(
                    size, machInst, zdn, zm, imm);
            }
        } else {
            if (bits(machInst, 9, 6) == 0) {
                return decodeSveFpArithImmPred(machInst);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveFpArithPred

    // C4.1.82.1 SVE floating-point round to integral value
    StaticInstPtr
    decodeSveFpRoundToInt(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = (uint8_t) bits(machInst, 18, 16);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=000
            return decodeSveUnaryPredF<SveFrintn>(size, machInst, zd, zn, pg);
          case 0x1:   // opc=001
            return decodeSveUnaryPredF<SveFrintp>(size, machInst, zd, zn, pg);
          case 0x2:   // opc=010
            return decodeSveUnaryPredF<SveFrintm>(size, machInst, zd, zn, pg);
          case 0x3:   // opc=011
            return decodeSveUnaryPredF<SveFrintz>(size, machInst, zd, zn, pg);
          case 0x4:   // opc=100
            return decodeSveUnaryPredF<SveFrinta>(size, machInst, zd, zn, pg);
          case 0x6:   // opc=110
            return decodeSveUnaryPredF<SveFrintx>(size, machInst, zd, zn, pg);
          case 0x7:   // opc=111
            return decodeSveUnaryPredF<SveFrinti>(size, machInst, zd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpRoundToInt

    // C4.1.82.2 SVE floating-point convert precision
    StaticInstPtr
    decodeSveFpCvtPrecision(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc2 = bits(machInst, 17, 16);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (opc2) {
          case 0x0:
            if (size == 0x2) {
                return new SveFcvtNarrow<uint32_t, uint16_t>(
                    machInst, zd, zn, pg);
            } else if (size == 0x3) {
                return new SveFcvtNarrow<uint64_t, uint16_t>(
                    machInst, zd, zn, pg);
            }
            break;
          case 0x1:
            if (size == 0x2) {
                return new SveFcvtWiden<uint16_t, uint32_t>(
                    machInst, zd, zn, pg);
            } else if (size == 0x3) {
                return new SveFcvtWiden<uint16_t, uint64_t>(
                    machInst, zd, zn, pg);
            }
            break;
          case 0x2:
            if (size == 0x3) {
                return new SveFcvtNarrow<uint64_t, uint32_t>(
                    machInst, zd, zn, pg);
            } else if (size == 0x2) {
                return new SveBFcvtNarrow<uint32_t, uint16_t>(
                    machInst, zd, zn, pg);
            } else if (size == 0x0) {
                return new SveFcvtxNarrow<uint64_t, uint32_t>(
                    machInst, zd, zn, pg);
            }
            break;
          case 0x3:
            if (size == 0x3) {
                return new SveFcvtWiden<uint32_t, uint64_t>(
                    machInst, zd, zn, pg);
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveFpCvtPrecision

    // C4.1.82.3 SVE floating-point unary operations
    StaticInstPtr
    decodeSveFpUnaryOp(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 17, 16);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (opc) {
          case 0x0: // opc=00
            return decodeSveUnaryPredF<SveFrecpx>(size, machInst, zd, zn, pg);
          case 0x1: // opc=01
            return decodeSveUnaryPredF<SveFsqrt>(size, machInst, zd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpUnaryOp

    // C4.1.82.4 SVE integer convert to floating-point
    StaticInstPtr
    decodeSveIntCvtToFp(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc_opc2_u = (bits(machInst, 23, 22) << 3) |
                             bits(machInst, 18, 16);

        switch (opc_opc2_u) {
          case 0xa:   // opc=01 opc2=01 U=0
            return new SveScvtfNarrow<uint16_t, uint16_t>(
                machInst, zd, zn, pg);
          case 0xb:   // opc=01 opc2=01 U=1
            return new SveUcvtfNarrow<uint16_t, uint16_t>(
                machInst, zd, zn, pg);
          case 0xc:   // opc=01 opc2=10 U=0
            return new SveScvtfNarrow<uint32_t, uint16_t>(
                machInst, zd, zn, pg);
          case 0xd:   // opc=01 opc2=10 U=1
            return new SveUcvtfNarrow<uint32_t, uint16_t>(
                machInst, zd, zn, pg);
          case 0xe:   // opc=01 opc2=11 U=0
            return new SveScvtfNarrow<uint64_t, uint16_t>(
                machInst, zd, zn, pg);
          case 0xf:   // opc=01 opc2=11 U=1
            return new SveUcvtfNarrow<uint64_t, uint16_t>(
                machInst, zd, zn, pg);
          case 0x14:  // opc=10 opc2=10 U=0
            return new SveScvtfNarrow<uint32_t, uint32_t>(
                machInst, zd, zn, pg);
          case 0x15:  // opc=10 opc2=10 U=1
            return new SveUcvtfNarrow<uint32_t, uint32_t>(
                machInst, zd, zn, pg);
          case 0x18:  // opc=11 opc2=00 U=0
            return new SveScvtfWiden<uint32_t, uint64_t>(
                machInst, zd, zn, pg);
          case 0x19:  // opc=11 opc2=00 U=1
            return new SveUcvtfWiden<uint32_t, uint64_t>(
                machInst, zd, zn, pg);
          case 0x1c:  // opc=11 opc2=10 U=0
            return new SveScvtfNarrow<uint64_t, uint32_t>(
                machInst, zd, zn, pg);
          case 0x1d:  // opc=11 opc2=10 U=1
            return new SveUcvtfNarrow<uint64_t, uint32_t>(
                machInst, zd, zn, pg);
          case 0x1e:  // opc=11 opc2=11 U=0
            return new SveScvtfNarrow<uint64_t, uint64_t>(
                machInst, zd, zn, pg);
          case 0x1f:  // opc=11 opc2=11 U=1
            return new SveUcvtfNarrow<uint64_t, uint64_t>(
                machInst, zd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpCvtToFp

    // C4.1.82.5 SVE floating-point convert to integer
    StaticInstPtr
    decodeSveFpCvtToInt(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc_u = (bits(machInst, 23, 22) << 1) | bits(machInst, 16);
        uint8_t opc2 = bits(machInst, 18, 17);

        switch (opc_u) {
          case 0x0:   // opc=00 U=0
            return decodeSveUnaryPredF<SveFlogb>(
                opc2, machInst, zd, zn, pg);
          case 0x2:   // opc=01 U=0
            switch (opc2) {
              case 0x1:   // opc=01 opc2=01 U=0
                return new SveFcvtzsNarrow<uint16_t, uint16_t>(
                    machInst, zd, zn, pg);
              case 0x2:   // opc=01 opc2=10 U=0
                return new SveFcvtzsWiden<uint16_t, uint32_t>(
                    machInst, zd, zn, pg);
              case 0x3:   // opc=01 opc2=11 U=0
                return new SveFcvtzsWiden<uint16_t, uint64_t>(
                    machInst, zd, zn, pg);
            }
            break;
          case 0x3:   // opc=01 U=1
            switch (opc2) {
              case 0x1:   // opc=01 opc2=01 U=1
                return new SveFcvtzuNarrow<uint16_t, uint16_t>(
                    machInst, zd, zn, pg);
              case 0x2:   // opc=01 opc2=10 U=1
                return new SveFcvtzuWiden<uint16_t, uint32_t>(
                    machInst, zd, zn, pg);
              case 0x3:   // opc=01 opc2=11 U=1
                return new SveFcvtzuWiden<uint16_t, uint64_t>(
                    machInst, zd, zn, pg);
            }
            break;
          case 0x4:   // opc=10 U=0
            switch (opc2) {
              case 0x2:   // opc=10 opc2=10 U=0
                return new SveFcvtzsNarrow<uint32_t, uint32_t>(
                    machInst, zd, zn, pg);
            }
            break;
          case 0x5:   // opc=10 U=1
            switch (opc2) {
              case 0x2:   // opc=10 opc2=10 U=1
                return new SveFcvtzuNarrow<uint32_t, uint32_t>(
                    machInst, zd, zn, pg);
            }
            break;
          case 0x6:   // opc=11 U=0
            switch (opc2) {
              case 0x0:   // opc=11 opc2=00 U=0
                return new SveFcvtzsNarrow<uint64_t, uint32_t>(
                    machInst, zd, zn, pg);
              case 0x2:   // opc=11 opc2=10 U=0
                return new SveFcvtzsWiden<uint32_t, uint64_t>(
                    machInst, zd, zn, pg);
              case 0x3:   // opc=11 opc2=11 U=0
                return new SveFcvtzsNarrow<uint64_t, uint64_t>(
                    machInst, zd, zn, pg);
            }
            break;
          case 0x7:   // opc=11 U=1
            switch (opc2) {
              case 0x0:   // opc=11 opc2=00 U=1
                return new SveFcvtzuNarrow<uint64_t, uint32_t>(
                    machInst, zd, zn, pg);
              case 0x2:   // opc=11 opc2=10 U=1
                return new SveFcvtzuWiden<uint32_t, uint64_t>(
                    machInst, zd, zn, pg);
              case 0x3:   // opc=11 opc2=11 U=1
                return new SveFcvtzuNarrow<uint64_t, uint64_t>(
                    machInst, zd, zn, pg);
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveFpCvtToInt

    // C4.1.82 SVE floating-point unary operations - merging predicated
    StaticInstPtr
    decodeSveFpUnaryOpMergingPred(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 20, 18);
        switch (op0) {
          case 0x0: case 0x1: // op0=00x
            return decodeSveFpRoundToInt(machInst);
          case 0x2:           // op0=010
            return decodeSveFpCvtPrecision(machInst);
          case 0x3:           // op0=011
            return decodeSveFpUnaryOp(machInst);
          case 0x4: case 0x5: // op0=10x
            return decodeSveIntCvtToFp(machInst);
          case 0x6: case 0x7: // op0=11x
            return decodeSveFpCvtToInt(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpUnaryOpMergingPred

    // C4.1.83.1 SVE floating-point multiply-accumulate writing addend
    StaticInstPtr
    decodeSveFpMulAddWrAddend(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 14, 13);
        uint8_t size = bits(machInst, 23, 22);

        if (size == 0x0) {
            switch (opc) {
              case 0x0:
                return new SveBfmla<uint16_t>(machInst, zda, zn, zm, pg);
              case 0x1:
                return new SveBfmls<uint16_t>(machInst, zda, zn, zm, pg);
            }
        } else {
            switch (opc) {
              case 0x0:
                return decodeSveTerPredF<SveFmla>(
                        size, machInst, zda, zn, zm, pg);
              case 0x1:
                return decodeSveTerPredF<SveFmls>(
                        size, machInst, zda, zn, zm, pg);
              case 0x2:
                return decodeSveTerPredF<SveFnmla>(
                        size, machInst, zda, zn, zm, pg);
              case 0x3:
                return decodeSveTerPredF<SveFnmls>(
                        size, machInst, zda, zn, zm, pg);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveFpMulAddWrAddend

    // C4.1.83.2 SVE floating-point multiply-accumulate writing multiplicand
    StaticInstPtr
    decodeSveFpMulAddWrMultiplicand(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex za = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 14, 13);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:
            return decodeSveTerPredF<SveFmad>(
                    size, machInst, zdn, za, zm, pg);
          case 0x1:
            return decodeSveTerPredF<SveFmsb>(
                    size, machInst, zdn, za, zm, pg);
          case 0x2:
            return decodeSveTerPredF<SveFnmad>(
                    size, machInst, zdn, za, zm, pg);
          case 0x3:
            return decodeSveTerPredF<SveFnmsb>(
                    size, machInst, zdn, za, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpMulAddWrMultiplicand

    // C4.1.83 SVE floating-point multiply-add
    StaticInstPtr
    decodeSveFpMulAdd(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 15);
        if (op0 == 0) {
            return decodeSveFpMulAddWrAddend(machInst);
        } else {
            return decodeSveFpMulAddWrMultiplicand(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpMulAdd

    // C4.1.84.1 SVE 32-bit gather prefetch (scalar plus 32-bit scaled offsets)
    StaticInstPtr
    decodeSveGather32PrfScaScaledOffset32(ExtMachInst machInst)
    {
        return new WarnUnimplemented("prf[bhwd]", machInst);
    }  // decodeSveGather32PrfScaScaledOffset32

    // C4.1.84.2 SVE 32-bit gather load halfwords (scalar plus 32-bit scaled
    // offsets)
    StaticInstPtr
    decodeSveGather32HalfScaScaledOffset32(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t)bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t xs = bits(machInst, 22);
        uint8_t ff = bits(machInst, 13);
        if (bits(machInst, 14)) {
            return
                new SveIndexedMemSV<uint32_t, uint16_t,
                                    SveGatherLoadSVMicroop,
                                    SveFirstFaultWritebackMicroop>(
                ff ? "ldff1" : "ld1", machInst, MemReadOp, zt, pg,
                rn, zm, true, xs, true, ff);
        } else {
            return
                new SveIndexedMemSV<int32_t, int16_t,
                                    SveGatherLoadSVMicroop,
                                    SveFirstFaultWritebackMicroop>(
                ff ? "ldff1" : "ld1", machInst, MemReadOp, zt, pg,
                rn, zm, true, xs, true, ff);
        }
        return new Unknown64(machInst);
    }  // decodeSveGather32HalfScaScaledOffset32

    // C4.1.84.3 SVE 32-bit gather load words (scalar plus 32-bit scaled
    // offsets)
    StaticInstPtr
    decodeSveGather32WordScaScaledOffset32(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t)bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t xs = bits(machInst, 22);
        uint8_t ff = bits(machInst, 13);
        return new SveIndexedMemSV<uint32_t, uint32_t,
                                    SveGatherLoadSVMicroop,
                                    SveFirstFaultWritebackMicroop>(
            ff ? "ldff1" : "ld1", machInst, MemReadOp, zt, pg, rn,
            zm, true, xs, true, ff);
    }  // decodeSveGather32WordScaScaledOffset32

    // C4.1.84.4 SVE contiguous prefetch (scalar plus immediate)
    StaticInstPtr
    decodeSveContigPrfSI(ExtMachInst machInst)
    {
        return new WarnUnimplemented("prf[bhwd]", machInst);
    }  // decodeSveContigPrfSI

    // C4.1.84.5 SVE2 32-bit gather non-temporal load (vector plus scalar)
    StaticInstPtr
    decodeSveGather32NTVS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex rm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 1) | bits(machInst, 13);

        return decodeSveGatherLoadVSInsts(dtype, machInst, zt, pg, zn, rm,
                                          true);
    }  // decodeSveGather32NTVS

    // C4.1.84.6 SVE contiguous prefetch (scalar plus scalar)
    StaticInstPtr
    decodeSveContigPrfSS(ExtMachInst machInst)
    {
        return new WarnUnimplemented("prf[bhwd]", machInst);
    }  // decodeSveContigPrfSS

    // C4.1.84.7 SVE 32-bit gather prefetch (vector plus immediate)
    StaticInstPtr
    decodeSveGather32PrfVI(ExtMachInst machInst)
    {
        return new WarnUnimplemented("prf[bhwd]", machInst);
    }  // decodeSveGather32PrfVI

    // C4.1.84.8 SVE 32-bit gather load (vector plus immediate)
    StaticInstPtr
    decodeSveGather32VI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t)bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t)bits(machInst, 9, 5);
        uint64_t imm = bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 1) | bits(machInst, 14);
        uint8_t ff = bits(machInst, 13);
        return decodeSveGatherLoadVIInsts(
            dtype, machInst, zt, pg, zn, imm, true, ff);
    }  // decodeSveGather32VI

    // C4.1.84.9 SVE load and broadcast element
    StaticInstPtr
    decodeSveLoadBroadcastElem(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        uint64_t imm = bits(machInst, 21, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 2) | bits(machInst, 14, 13);
        return decodeSveContigLoadSIInsts<SveLoadAndRepl>(
                dtype, machInst, zt, pg, rn, imm, false, false, true);
    }  // decodeSveLoadBroadcastElem

    // C4.1.84.10 SVE 32-bit gather load (scalar plus 32-bit unscaled offsets)
    StaticInstPtr
    decodeSveGather32ScaUnscaleOffset32(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 1) | bits(machInst, 14);
        uint8_t xs = bits(machInst, 22);
        uint8_t ff = bits(machInst, 13);
        return decodeSveGatherLoadSVInsts(dtype, machInst, zt, pg, rn, zm,
                                          true, true, xs, false, ff);
    }  // decodeSveGather32ScaUnscaleOffset32

    // C4.1.84 SVE Memory - 32-bit Gather and Unsized Contiguous
    StaticInstPtr
    decodeSveMemGather32AndUnsizedContig(ExtMachInst machInst)
    {
        uint8_t op2_b15 = bits(machInst, 15);
        if (op2_b15 == 0x0) {   // op2=0xx
            uint8_t b24_23 = bits(machInst, 24, 23);
            if (b24_23 != 0x3 && bits(machInst, 21) == 0) {
                // op0!=11 op1=x0 op2=0xx
                return decodeSveGather32ScaUnscaleOffset32(machInst);
            }
            switch (b24_23) {
              case 0x0:   // op0=00 op2=0xx
                if (bits(machInst, 21) && bits(machInst, 4) == 0) {
                    // op0=00 op1=x1 op2=0xx op3=0
                    return decodeSveGather32PrfScaScaledOffset32(machInst);
                }
                break;
              case 0x1:   // op0=01 op2=0xx
                if (bits(machInst, 21)) {
                    // op0=01 op1=x1 op2=0xx
                    return decodeSveGather32HalfScaScaledOffset32(machInst);
                }
                break;
              case 0x2:   // op0=10 op2=0xx
                if (bits(machInst, 21)) {
                    // op0=10 op1=x1 op2=0xx
                    return decodeSveGather32WordScaScaledOffset32(machInst);
                }
                break;
              case 0x3:   // op0=11 op2=0xx
                if (bits(machInst, 22) == 0 && bits(machInst, 14, 13) == 0x0 &&
                        bits(machInst, 4) == 0) {
                    // op0=11 op1=0x op2=000 op3=0
                    // LDR (predicate)
                    RegIndex pt = (RegIndex) (uint8_t)
                        bits(machInst, 3, 0);
                    RegIndex rn = makeSP(
                            (RegIndex) (uint8_t) bits(machInst, 9, 5));
                    uint64_t imm = sext<9>((bits(machInst, 21, 16) << 3) |
                                           bits(machInst, 12, 10));
                    return new SveLdrPred(machInst, pt, rn, imm);
                } else if (bits(machInst, 22) == 0 &&
                           bits(machInst, 14, 13) == 0x2) {
                    // op0=11 op1=0x op2=010
                    // LDR (vector)
                    RegIndex zt = (RegIndex) (uint8_t)
                        bits(machInst, 4, 0);
                    RegIndex rn = makeSP(
                            (RegIndex) (uint8_t) bits(machInst, 9, 5));
                    uint64_t imm = sext<9>((bits(machInst, 21, 16) << 3) |
                                           bits(machInst, 12, 10));
                    return new SveLdrVec(machInst, zt, rn, imm);
                } else if (bits(machInst, 22) == 1 &&
                           bits(machInst, 4) == 0) {
                    // op0=11 op1=1x op2=0xx op3=0
                    return decodeSveContigPrfSI(machInst);
                }
                break;
            }
        } else {  // op2=1xx
            if (bits(machInst, 22)) {   // op1=1x op2=1xx
                return decodeSveLoadBroadcastElem(machInst);
            } else if (bits(machInst, 21)) {   // op1=01 op2=1xx
                return decodeSveGather32VI(machInst);
            } else {    // op1=00 op2=1xx
                if (bits(machInst, 14, 13) == 0x2 && bits(machInst, 4) == 0) {
                    // op1=00 op2=110 op3=0
                    return decodeSveContigPrfSS(machInst);
                } else if (bits(machInst, 14, 13) == 0x3 &&
                           bits(machInst, 4) == 0) {
                    // op1=00 op2=111 op3=0
                    return decodeSveGather32PrfVI(machInst);
                } else if (bits(machInst, 14) == 0x0) {
                    // op1=00 op2=10x
                    return decodeSveGather32NTVS(machInst);
                }
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveMemGather32AndUnsizedContig

    // C4.1.85.1 SVE contiguous non-temporal load (scalar plus immediate)
    StaticInstPtr
    decodeSveContigNTLoadSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        uint64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 2) | bits(machInst, 24, 23);

        return decodeSveContigLoadSIInsts<SveContigNTLoadSI>(
            dtype, machInst, zt, pg, rn, imm, false, true);
    }  // decodeSveContigNTLoadSI

    // C4.1.85.2 SVE contiguous load (quadwords, scalar plus immediate)
    StaticInstPtr
    decodeSveContigLoadQuadSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        uint64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t dtype = bits(machInst, 24, 23);

        switch (dtype) {
          case 0x2:
            return new SveContigLoadQuadSI<__uint128_t, uint32_t>(
                "ld1w", machInst, zt, pg, rn, imm);
          case 0x3:
            return new SveContigLoadQuadSI<__uint128_t, uint64_t>(
                "ld1d", machInst, zt, pg, rn, imm);
        }
        return new Unknown64(machInst);
    }  // decodeSveContigLoadQuadSI

    // C4.1.85.3 SVE load multiple structures (quadwords, scalar plus
    // immediate)
    StaticInstPtr
    decodeSveLoadStructsQuadSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        int64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t num = bits(machInst, 24, 23);

        if (num != 0) {
            num++;
            imm *= num;
            return decodeSveStructLoadQuadSIInstsByNReg(
                    machInst, zt, pg, rn, imm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveLoadStructsQuadSI

    // C4.1.85.4 SVE contiguous load (quadwords, scalar plus scalar)
    StaticInstPtr
    decodeSveContigLoadQuadSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t dtype = bits(machInst, 24, 23);

        if (rm == 0x1f) {
            return new Unknown64(machInst);
        }

        switch (dtype) {
          case 0x2:
            return new SveContigLoadQuadSS<__uint128_t, uint32_t>(
                "ld1w", machInst, zt, pg, rn, rm);
          case 0x3:
            return new SveContigLoadQuadSS<__uint128_t, uint64_t>(
                "ld1d", machInst, zt, pg, rn, rm);
        }
        return new Unknown64(machInst);
    }  // decodeSveContigLoadQuadSS

    // C4.1.85.5 SVE contiguous non-temporal load (scalar plus scalar)
    StaticInstPtr
    decodeSveContigNTLoadSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 2) | bits(machInst, 24, 23);

        if (rm == 0x1f) {
            return new Unknown64(machInst);
        }

        return decodeSveContigLoadSSInsts<SveContigNTLoadSS>(
            dtype, machInst, zt, pg, rn, rm, false, true);
    }  // decodeSveContigNTLoadSS

    // C4.1.85.6 SVE load multiple structures (quadwords, scalar plus scalar)
    StaticInstPtr
    decodeSveLoadStructsQuadSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t num = bits(machInst, 24, 23);

        if (rm != 0x1f && num != 0) {
            num++;
            return decodeSveStructLoadQuadSSInstsByNReg(
                    machInst, zt, pg, rn, rm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveLoadStructsQuadSS

    // C4.1.85.7 SVE load and broadcast quadword (scalar plus immediate)
    StaticInstPtr
    decodeSveLoadBroadcastQuadSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex)(uint8_t) bits(machInst, 9, 5));
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        uint64_t imm = sext<4>(bits(machInst, 19, 16));

        uint8_t msz_esz = bits(machInst, 24, 21);

        switch (msz_esz) {
            // Load-Broadcast Quad-word Variants
            case 0b0000: // 0x0:
                return new SveLd1RqSI<uint8_t, uint8_t>("ld1rqb",
                        machInst, zt, pg, rn, imm);
            case 0b0100: // 0x4:
                return new SveLd1RqSI<uint16_t, uint16_t>("ld1rqh",
                        machInst, zt, pg, rn, imm);
            case 0b1000: // 0x8:
                return new SveLd1RqSI<uint32_t, uint32_t>("ld1rqw",
                        machInst, zt, pg, rn, imm);
            case 0b1100: // 0xc:
                return new SveLd1RqSI<uint64_t, uint64_t>("ld1rqd",
                        machInst, zt, pg, rn, imm);

            // Load-Broadcast Octa-word Variants
            case 0b0001: // 0x1:
                return new SveLd1RoSI<uint8_t, uint8_t>("ld1rob",
                        machInst, zt, pg, rn, imm);
            case 0b0101: // 0x5:
                return new SveLd1RoSI<uint16_t, uint16_t>("ld1roh",
                        machInst, zt, pg, rn, imm);
            case 0b1001: // 0x9:
                return new SveLd1RoSI<uint32_t, uint32_t>("ld1row",
                        machInst, zt, pg, rn, imm);
            case 0b1101: // 0xd:
                return new SveLd1RoSI<uint64_t, uint64_t>("ld1rod",
                        machInst, zt, pg, rn, imm);

            default:
              return new Unknown64(machInst);
        }

        return new Unknown64(machInst);
    }  // decodeSveLoadBroadcastQuadSI

    // C4.1.85.8 SVE contiguous load (scalar plus immediate)
    StaticInstPtr
    decodeSveContigLoadSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        uint64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        return decodeSveContigLoadSIInsts<SveContigLoadSI>(
            bits(machInst, 24, 21), machInst, zt, pg, rn, imm, false, false);
    }  // decodeSveContigLoadSI

    // C4.1.85.9 SVE contiguous non-fault load (scalar plus immediate)
    StaticInstPtr
    decodeSveContigNFLoadSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        uint64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        return decodeSveContigLoadSIInsts<SveContigNFLoadSI>(
            bits(machInst, 24, 21), machInst, zt, pg, rn, imm, true, false);
    }  // decodeSveContigNFLoadSI

    // C4.1.85.10 SVE load and broadcast quadword (scalar plus scalar)
    StaticInstPtr
    decodeSveLoadBroadcastQuadSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex)(uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex)(uint8_t) bits(machInst, 9, 5));
        RegIndex pg = (RegIndex)(uint8_t) bits(machInst, 12, 10);
        RegIndex rm = (RegIndex)(uint8_t) bits(machInst, 20, 16);

        uint8_t msz_esz = bits(machInst, 24, 21);

        switch (msz_esz) {
            // Load-Broadcast Quad-word Variants
            case 0b0000: // 0x0:
                return new SveLd1RqSS<uint8_t, uint8_t>("ld1rqb",
                        machInst, zt, pg, rn, rm);
            case 0b0100: // 0x4:
                 return new SveLd1RqSS<uint16_t, uint16_t>("ld1rqh",
                        machInst, zt, pg, rn, rm);
            case 0b1000: // 0x8:
                return new SveLd1RqSS<uint32_t, uint32_t>("ld1rqw",
                        machInst, zt, pg, rn, rm);
            case 0b1100: // 0xc:
                return new SveLd1RqSS<uint64_t, uint64_t>("ld1rqd",
                        machInst, zt, pg, rn, rm);

            // Load-Broadcast Octa-word Variants
            case 0b0001: // 0x1:
                return new SveLd1RoSS<uint8_t, uint8_t>("ld1rob",
                        machInst, zt, pg, rn, rm);
            case 0b0101: // 0x5:
                return new SveLd1RoSS<uint16_t, uint16_t>("ld1roh",
                        machInst, zt, pg, rn, rm);
            case 0b1001: // 0x9:
                return new SveLd1RoSS<uint32_t, uint32_t>("ld1row",
                        machInst, zt, pg, rn, rm);
            case 0b1101: // 0xd:
                return new SveLd1RoSS<uint64_t, uint64_t>("ld1rod",
                        machInst, zt, pg, rn, rm);

            default:
              return new Unknown64(machInst);
        }

        return new Unknown64(machInst);
    }  // decodeSveLoadBroadcastQuadSS

    // C4.1.85.11 SVE contiguous load (scalar plus scalar)
    StaticInstPtr
    decodeSveContigLoadSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        if (rm == 0x1f) {
            return new Unknown64(machInst);
        }

        return decodeSveContigLoadSSInsts<SveContigLoadSS>(
            bits(machInst, 24, 21), machInst, zt, pg, rn, rm, false, false);
    }  // decodeSveContigLoadSS

    // C4.1.85.12 SVE contiguous first-fault load (scalar plus scalar)
    StaticInstPtr
    decodeSveContigFFLoadSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        return decodeSveContigLoadSSInsts<SveContigFFLoadSS>(
            bits(machInst, 24, 21), machInst, zt, pg, rn, rm, true, false);
    }  // decodeSveContigFFLoadSS

    // C4.1.85.13 SVE load multiple structures (scalar plus immediate)
    StaticInstPtr
    decodeSveLoadStructsSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        int64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t num = bits(machInst, 22, 21);

        if (num != 0) {
            num++;
            imm *= num;
            return decodeSveStructLoadSIInsts(msz, machInst,
                    zt, pg, rn, imm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveLoadStructsSI

    // C4.1.85.14 SVE load multiple structures (scalar plus scalar)
    StaticInstPtr
    decodeSveLoadStructsSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t num = bits(machInst, 22, 21);

        if (rm != 0x1f && num != 0) {
            num++;
            return decodeSveStructLoadSSInsts(msz, machInst,
                    zt, pg, rn, rm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveLoadStructsSS

    // C4.1.85 SVE Memory - Contiguous Load
    StaticInstPtr
    decodeSveMemContigLoad(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 22, 21);
        uint8_t op1 = bits(machInst, 20);
        uint8_t op2 = bits(machInst, 15, 13);

        switch (op2) {
          case 0x0:   // op2=000
            return decodeSveLoadBroadcastQuadSS(machInst);
          case 0x1:   // op2=001
            if (op1 == 0x0) {  // op1=0 op2=001
                return decodeSveLoadBroadcastQuadSI(machInst);
            } else if (op0 == 0x0) {  // op0=00 op1=1 op2=001
                return decodeSveContigLoadQuadSI(machInst);
            }
            break;
          case 0x2:   // op2=010
            return decodeSveContigLoadSS(machInst);
          case 0x3:   // op2=011
            return decodeSveContigFFLoadSS(machInst);
          case 0x4:
            if (op0 == 0x0) {   // op0=00 op2=100
                return decodeSveContigLoadQuadSS(machInst);
            } else if (op0 == 0x1) { // op0=01 op2=100
                return decodeSveLoadStructsQuadSS(machInst);
            }
            break;
          case 0x5:   // op2=101
            if (op1 == 0x0) {   // op1=0 op2=101
                return decodeSveContigLoadSI(machInst);
            } else {  // op1=1 op2=101
                return decodeSveContigNFLoadSI(machInst);
            }
          case 0x6:   // op2=110
            if (op0 == 0x0) {   // op0=00 op2=110
                return decodeSveContigNTLoadSS(machInst);
            } else {    // op0!=00 op2=110
                return decodeSveLoadStructsSS(machInst);
            }
          case 0x7:   // op2=111
            if (op1 == 0) {
                if (op0 == 0x0) {   // op0=00 op1=0 op2=111
                    return decodeSveContigNTLoadSI(machInst);
                } else {  // op0!=00 op1=0 op2=111
                    return decodeSveLoadStructsSI(machInst);
                }
            } else {
                if (op0 == 0x0) {   // op0=00 op1=1 op2=111
                    return decodeSveLoadStructsQuadSI(machInst);
                }
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveMemContigLoad

    // C4.1.86.1 SVE 64-bit gather prefetch (scalar plus 64-bit scaled offsets)
    StaticInstPtr
    decodeSveGather64PrfScaScaledOffset64(ExtMachInst machInst)
    {
        return new WarnUnimplemented("prf[bhwd]", machInst);
    }  // decodeSveGather64PrfScaScaledOffset64

    // C4.1.86.2 SVE 64-bit gather prefetch (scalar plus unpacked 32-bit scaled
    // offsets)
    StaticInstPtr
    decodeSveGather64PrfScaUnpackScaleOffset32(ExtMachInst machInst)
    {
        return new WarnUnimplemented("prf[bhwd]", machInst);
    }  // decodeSveGather64PrfScaUnpackScaleOffset32

    // C4.1.86.3 SVE 64-bit gather prefetch (vector plus immediate)
    StaticInstPtr
    decodeSveGather64PrfVI(ExtMachInst machInst)
    {
        return new WarnUnimplemented("prf[bhwd]", machInst);
    }  // decodeSveGather64PrfVI

    // C4.1.86.4 SVE2 64-bit gather non-temporal load (vector plus scalar)
    StaticInstPtr
    decodeSve2Gather64NTVS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex rm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 1) | bits(machInst, 14);

        return decodeSveGatherLoadVSInsts(dtype, machInst, zt, pg, zn, rm,
                                          false);
    }  // decodeSve2Gather64NTVS

    // C4.1.86.5 SVE 64-bit gather load (vector plus immediate)
    StaticInstPtr
    decodeSveGather64VI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint64_t imm = bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 1) | bits(machInst, 14);
        uint8_t ff = bits(machInst, 13);
        return decodeSveGatherLoadVIInsts(dtype, machInst, zt, pg, zn, imm,
                                          false, ff);
    }  // decodeSveGather64VI

    // C4.1.86.6 SVE 64-bit gather load (scalar plus 64-bit unscaled offsets)
    StaticInstPtr
    decodeSveGather64ScaUnscaledOffset64(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 1) | bits(machInst, 14);
        uint8_t ff = bits(machInst, 13);
        return decodeSveGatherLoadSVInsts(dtype, machInst, zt, pg, rn, zm,
                                          false, false, false, false, ff);
    }  // decodeSveGather64ScaUnscaledOffset64

    // C4.1.86.7 SVE 64-bit gather load (scalar plus unpacked 32-bit unscaled
    // offsets)
    StaticInstPtr
    decodeSveGather64ScaUnpackUnscaleOffset32(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 1) | bits(machInst, 14);
        uint8_t xs = bits(machInst, 22);
        uint8_t ff = bits(machInst, 13);
        return decodeSveGatherLoadSVInsts(dtype, machInst, zt, pg, rn, zm,
                                          false, true, xs, false, ff);
    }  // decodeSveGather64ScaUnpackUnscaleOffset32

    // C4.1.86.8 SVE 64-bit gather load (scalar plus 64-bit scaled offsets)
    StaticInstPtr
    decodeSveGather64ScaScaledOffset64(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 1) | bits(machInst, 14);
        uint8_t ff = bits(machInst, 13);
        return decodeSveGatherLoadSVInsts(dtype, machInst, zt, pg, rn, zm,
                                          false, false, false, true, ff);
    }  // decodeSveGather64ScaScaledOffset64

    // C4.1.86.9 SVE 64-bit gather load (scalar plus 32-bit unpacked scaled
    // offsets)
    StaticInstPtr
    decodeSveGather64ScaUnpackScaleOffset32(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 1) | bits(machInst, 14);
        uint8_t xs = bits(machInst, 22);
        uint8_t ff = bits(machInst, 13);
        return decodeSveGatherLoadSVInsts(dtype, machInst, zt, pg, rn, zm,
                                          false, true, xs, true, ff);
    }  // decodeSveGather64ScaUnpackScaleOffset32

    // C4.1.86 SVE Memory - 64-bit Gather
    StaticInstPtr
    decodeSveMemGather64(ExtMachInst machInst)
    {
        switch ((bits(machInst, 21) << 1) | bits(machInst, 15)) {
          case 0x0:   // op1=x0 op2=0xx
            return decodeSveGather64ScaUnpackUnscaleOffset32(machInst);
          case 0x1:   // op1=x0 op2=1xx
            if (bits(machInst, 22)) {   // op1=10 op2=1xx
                return decodeSveGather64ScaUnscaledOffset64(machInst);
            } else {
                if (bits(machInst, 14, 13) == 0x3 && bits(machInst, 4) == 0) {
                    // op1=00 op2=111 op3=0
                    return decodeSveGather64PrfVI(machInst);
                } else if (bits(machInst, 13) == 0x0) { // op1=00 op2=1x0
                    return decodeSve2Gather64NTVS(machInst);
                } else if (bits(machInst, 14, 13) == 0x1) { // op1=00 op2=101
                    // LD1Q
                    RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                    RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
                    RegIndex rm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
                    RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);

                    return new SveIndexedMemVS<__uint128_t, __uint128_t,
                                               SveGatherLoadQuadVSMicroop,
                                               SveFirstFaultWritebackMicroop>(
                        "ld1q", machInst, MemReadOp, zt, pg, zn, rm, false);
                }
            }
            break;
          case 0x2:   // op1=x1 op2=0xx
            if (bits(machInst, 24, 23) != 0x0) {  // op0!=00 op1=x1 op2=0xx
                return decodeSveGather64ScaUnpackScaleOffset32(machInst);
            } else if (bits(machInst, 4) == 0) {
                // op0=00 op1=x1 op2=0xx op3=0
                return decodeSveGather64PrfScaUnpackScaleOffset32(machInst);
            }
            break;
          case 0x3:   // op1=x1 op2=1xx
            if (bits(machInst, 22) == 0) {  // op1=01 op2=1xx
                return decodeSveGather64VI(machInst);
            } else {
                if (bits(machInst, 24, 23) != 0x0) { // op0!=00 op1=11 op2=1xx
                    return decodeSveGather64ScaScaledOffset64(machInst);
                } else if (bits(machInst, 4) == 0) {
                    // op0=00 op1=11 op2=1xx op3=0
                    return decodeSveGather64PrfScaScaledOffset64(machInst);
                }
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveMemGather64

    // C4.1.87.1 SVE2 64-bit scatter non-temporal store (vector plus scalar)
    StaticInstPtr
    decodeSve2Scatter64NTVS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t)bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t)bits(machInst, 9, 5);
        RegIndex rm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);

        return decodeSveScatterStoreVSInsts(msz, machInst, zt, pg, zn, rm,
                                            false);
    }  // decodeSve2Scatter64NTVS

    // C4.1.87.2 SVE2 32-bit scatter non-temporal store (vector plus scalar)
    StaticInstPtr
    decodeSve2Scatter32NTVS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t)bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t)bits(machInst, 9, 5);
        RegIndex rm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);

        return decodeSveScatterStoreVSInsts(msz, machInst, zt, pg, zn, rm,
                                            true);
    }  // decodeSve2Scatter32NTVS

    // C4.1.87 SVE Memory - Non-temporal and Quadword Scatter Store
    StaticInstPtr
    decodeSveMemNTAndQScatter(ExtMachInst machInst)
    {
        uint8_t op1 = bits(machInst, 21);

        if (op1 == 0) {
            uint8_t op0_b22 = bits(machInst, 22);
            if (op0_b22 == 0) {
                return decodeSve2Scatter64NTVS(machInst);
            } else {
                return decodeSve2Scatter32NTVS(machInst);
            }
        } else {
            uint8_t op0 = bits(machInst, 24, 22);
            if (op0 == 0x0) {
                // ST1Q
                RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
                RegIndex rm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
                RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);

                return new SveIndexedMemVS<__uint128_t, __uint128_t,
                                           SveScatterStoreQuadVSMicroop,
                                           SveFirstFaultWritebackMicroop>(
                    "st1q", machInst, MemWriteOp, zt, pg, zn, rm, false);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveMemNTAndQScatter

    // C4.1.88.1 SVE contiguous non-temporal store (scalar plus scalar)
    StaticInstPtr
    decodeSveContigNTStoreSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 2) | bits(machInst, 24, 23);

        if (rm == 0x1f) {
            return new Unknown64(machInst);
        }

        return decodeSveContigStoreSSInsts<SveContigStoreSS>(
            dtype, machInst, zt, pg, rn, rm, true);
    }  // decodeSveContigNTStoreSS

    // C4.1.88.2 SVE store multiple structures (scalar plus scalar)
    StaticInstPtr
    decodeSveStoreStructsSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t num = bits(machInst, 22, 21);

        if (rm != 0x1f && num != 0) {
            num++;
            return decodeSveStructStoreSSInsts(msz, machInst,
                    zt, pg, rn, rm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveStoreStructsSS

    // C4.1.88 SVE Memory - Non-temporal and Multi-register Contiguous Store
    StaticInstPtr
    decodeSveMemNTAndMultiRegContigStore(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 22, 21);
        if (op0 == 0x0) {
            return decodeSveContigNTStoreSS(machInst);
        } else {
            return decodeSveStoreStructsSS(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveMemNTAndMultiRegContigStore

    // C4.1.89.1 SVE store multiple structures (quadwords, scalar plus
    // immediate)
    StaticInstPtr
    decodeSveStoreStructsQuadSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        int64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t num = bits(machInst, 23, 22);

        if (num != 0) {
            num++;
            imm *= num;
            return decodeSveStructStoreQuadSIInstsByNReg(
                    machInst, zt, pg, rn, imm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveStoreStructsQuadSI

    // C4.1.89.2 SVE store multiple structures (quadwords, scalar plus scalar)
    StaticInstPtr
    decodeSveStoreStructsQuadSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t num = bits(machInst, 23, 22);

        if (rm != 0x1f && num != 0) {
            num++;
            return decodeSveStructStoreQuadSSInstsByNReg(
                    machInst, zt, pg, rn, rm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveStoreStructsQuadSS

    // C4.1.89.3 SVE contiguous store (scalar plus scalar)
    StaticInstPtr
    decodeSveContigStoreSS(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex rm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t dtype = bits(machInst, 24, 21);

        if (rm == 0x1f) {
            return new Unknown64(machInst);
        }

        switch (dtype) {
          case 0x8:
            return new SveContigStoreQuadSS<__uint128_t, uint32_t>(
                "st1w", machInst, zt, pg, rn, rm);
          case 0xe:
            return new SveContigStoreQuadSS<__uint128_t, uint64_t>(
                "st1d", machInst, zt, pg, rn, rm);
        }
        return decodeSveContigStoreSSInsts<SveContigStoreSS>(
            dtype, machInst, zt, pg, rn, rm, false);
    }  // decodeSveContigStoreSS

    // C4.1.89 SVE Memory - Contiguous Store and Unsized Contiguous
    StaticInstPtr
    decodeSveMemNTContigStoreAndUnsizedContig(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 24, 22);
        uint8_t op2 = bits(machInst, 14);
        if (op2 == 0x0) {   // op2=0
            switch (op0) {
              case 0x0: case 0x1: case 0x2: case 0x3: // op0=0xx
                switch (bits(machInst, 21, 20)) {
                  case 0x0:           // op0=0xx op1=00 op2=0
                    return decodeSveStoreStructsQuadSI(machInst);
                  case 0x2: case 0x3: // op0=0xx op1=1x op2=0
                    return decodeSveStoreStructsQuadSS(machInst);
                }
                break;
              case 0x6: // op0=110
                if (bits(machInst, 15) == 0x0) {  // op0=110 op2=0 op3=0
                    // STR (predicate)
                    RegIndex pt = (RegIndex) (uint8_t) bits(machInst, 3, 0);
                    RegIndex rn = makeSP(
                        (RegIndex) (uint8_t) bits(machInst, 9, 5));
                    int16_t imm = sext<9>((bits(machInst, 21, 16) << 3) |
                                          bits(machInst, 12, 10));
                    return new SveStrPred(machInst, pt, rn, imm);
                }
                break;
            }
        } else {  // op2=1
            if (op0 == 0x6) { // op0=110 op2=1
                // STR (vector)
                RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
                RegIndex rn = makeSP(
                    (RegIndex) (uint8_t) bits(machInst, 9, 5));
                int16_t imm = sext<9>((bits(machInst, 21, 16) << 3) |
                                      bits(machInst, 12, 10));
                return new SveStrVec(machInst, zt, rn, imm);
            } else {
                return decodeSveContigStoreSS(machInst);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveMemNTContigStoreAndUnsizedContig

    // C4.1.90.1 SVE 64-bit scatter store (scalar plus 64-bit unscaled offsets)
    StaticInstPtr
    decodeSveScatter64ScaUnscaleOffset64(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);

        return decodeSveScatterStoreSVInsts(msz, machInst, zt, pg, rn, zm,
                                            false, false, false, false);
    }  // decodeSveScatter64ScaUnscaleOffset64

    // C4.1.90.2 SVE 64-bit scatter store (scalar plus 64-bit scaled offsets)
    StaticInstPtr
    decodeSveScatter64ScaScaledOffset64(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t)bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);

        return decodeSveScatterStoreSVInsts(msz, machInst, zt, pg, rn, zm,
                                            false, false, false, true);
    }  // decodeSveScatter64ScaScaledOffset64

    // C4.1.90.3 SVE 64-bit scatter store (vector plus immediate)
    StaticInstPtr
    decodeSveScatter64VI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t)bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t)bits(machInst, 9, 5);
        uint64_t imm = bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);

        return decodeSveScatterStoreVIInsts(msz, machInst, zt, pg, zn, imm,
                                            false);
    }  // decodeSveScatter64VI

    // C4.1.90.4 SVE 32-bit scatter store (vector plus immediate)
    StaticInstPtr
    decodeSveScatter32VI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t)bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t)bits(machInst, 9, 5);
        uint64_t imm = bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);

        return decodeSveScatterStoreVIInsts(msz, machInst, zt, pg, zn, imm,
                                            true);
    }  // decodeSveScatter32VI

    // C4.1.90 SVE Memory - Scatter
    StaticInstPtr
    decodeSveMemScatter(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 22, 21);
        switch (op0) {
          case 0x0:
            return decodeSveScatter64ScaUnscaleOffset64(machInst);
          case 0x1:
            if (bits(machInst, 24, 23) != 0x0) {
                return decodeSveScatter64ScaScaledOffset64(machInst);
            }
            break;
          case 0x2:
            return decodeSveScatter64VI(machInst);
          case 0x3:
            if (bits(machInst, 24, 23) != 0x3) {
                return decodeSveScatter32VI(machInst);
            }
            break;
        }
        return new Unknown64(machInst);
    }  // decodeSveMemScatter

    // C4.1.91.1 SVE contiguous non-temporal store (scalar plus immediate)
    StaticInstPtr
    decodeSveContigNTStoreSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        int8_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t dtype = (bits(machInst, 24, 23) << 2) | bits(machInst, 24, 23);

        return decodeSveContigStoreSIInsts<SveContigStoreSI>(
            dtype, machInst, zt, pg, rn, imm, true);
    }  // decodeSveContigNTStoreSI

    // C4.1.91.2 SVE contiguous store (scalar plus immediate)
    StaticInstPtr
    decodeSveContigStoreSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        int8_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t dtype = bits(machInst, 24, 21);

        switch (dtype) {
          case 0x8:
            return new SveContigStoreQuadSI<__uint128_t, uint32_t>(
                "st1w", machInst, zt, pg, rn, imm);
          case 0xe:
            return new SveContigStoreQuadSI<__uint128_t, uint64_t>(
                "st1d", machInst, zt, pg, rn, imm);
        }
        return decodeSveContigStoreSIInsts<SveContigStoreSI>(
            dtype, machInst, zt, pg, rn, imm, false);
    }  // decodeSveContigStoreSI

    // C4.1.91.3 SVE store multiple structures (scalar plus immediate)
    StaticInstPtr
    decodeSveStoreStructsSI(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        int64_t imm = sext<4>(bits(machInst, 19, 16));
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t num = bits(machInst, 22, 21);

        if (num != 0) {
            num++;
            imm *= num;
            return decodeSveStructStoreSIInsts(msz, machInst,
                    zt, pg, rn, imm, num);
        }
        return new Unknown64(machInst);
    }  // decodeSveStoreStructsSI

    // C4.1.91 SVE Memory - Contiguous Store with Immediate Offset
    StaticInstPtr
    decodeSveMemContigStoreWithImmOffset(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 22, 21);
        uint8_t op1 = bits(machInst, 20);

        if (op1 == 0x0) {           // op1=0
            return decodeSveContigStoreSI(machInst);
        } else if (op0 == 0x0) {    // op0=00 op1=1
            return decodeSveContigNTStoreSI(machInst);
        } else {                    // op0!=00 op1=1
            return decodeSveStoreStructsSI(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveMemContigStoreWithImmOffset

    // C4.1.92.1 SVE 64-bit scatter store (scalar plus unpacked 32-bit unscaled
    // offsets)
    StaticInstPtr
    decodeSveScatter64ScaUnpackUnscaleOffset32(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t xs = bits(machInst, 14);

        return decodeSveScatterStoreSVInsts(msz, machInst, zt, pg, rn, zm,
                                            false, true, xs, false);
    }  // decodeSveScatter64ScaUnpackUnscaleOffset32

    // C4.1.92.2 SVE 64-bit scatter store (scalar plus unpacked 32-bit scaled
    // offsets)
    StaticInstPtr
    decodeSveScatter64ScaUnpackScaleOffset32(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t xs = bits(machInst, 14);

        return decodeSveScatterStoreSVInsts(msz, machInst, zt, pg, rn, zm,
                                            false, true, xs, true);
    }  // decodeSveScatter64ScaUnpackScaleOffset32

    // C4.1.92.3 SVE 32-bit scatter store (scalar plus 32-bit unscaled offsets)
    StaticInstPtr
    decodeSveScatter32ScaUnscaleOffset32(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t xs = bits(machInst, 14);

        return decodeSveScatterStoreSVInsts(msz, machInst, zt, pg, rn, zm,
                                            true, true, xs, false);
    }  // decodeSveScatter32ScaUnscaleOffset32

    // C4.1.92.4 SVE 32-bit scatter store (scalar plus 32-bit scaled offsets)
    StaticInstPtr
    decodeSveScatter32ScaScaledOffset32(ExtMachInst machInst)
    {
        RegIndex zt = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex rn = makeSP((RegIndex) (uint8_t) bits(machInst, 9, 5));
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t)bits(machInst, 12, 10);
        uint8_t msz = bits(machInst, 24, 23);
        uint8_t xs = bits(machInst, 22);

        return decodeSveScatterStoreSVInsts(msz, machInst, zt, pg, rn, zm,
                                            true, true, xs, true);
    }  // decodeSveScatter32ScaScaledOffset32

    // C4.1.92.8 SVE permute vector elements
    StaticInstPtr
    decodeSvePermVecElem(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t size = (uint8_t)bits(machInst, 23, 22);

        uint8_t opc = bits(machInst, 12, 10);
        switch (opc) {
          case 0x0:   // opc=000
            return decodeSveBinUnpredU<SveZip1>(size, machInst, zd, zn, zm);
          case 0x1:   // opc=001
            return decodeSveBinUnpredU<SveZip2>(size, machInst, zd, zn, zm);
          case 0x2:   // opc=010
            return decodeSveBinUnpredU<SveUzp1>(size, machInst, zd, zn, zm);
          case 0x3:   // opc=011
            return decodeSveBinUnpredU<SveUzp2>(size, machInst, zd, zn, zm);
          case 0x4:   // opc=100
            return decodeSveBinUnpredU<SveTrn1>(size, machInst, zd, zn, zm);
          case 0x5:   // opc=101
            return decodeSveBinUnpredU<SveTrn2>(size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSvePermVecElem

    // C4.1.92.13 SVE two-way dot product
    StaticInstPtr
    decodeSve2WayDotProd(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 20, 16);
        uint8_t U = (uint8_t)bits(machInst, 10);

        if (U) {
            return new SveUdot2wayv<uint16_t, uint16_t, uint32_t>(
                    machInst, zd, zn, zm);
        } else {
            return new SveSdot2wayv<int16_t, int16_t, int32_t>(
                    machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSveScatter32ScaScaledOffset32

    // C4.1.92.14 SVE two-way dot product (indexed)
    StaticInstPtr
    decodeSve2WayDotProdIdx(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t)bits(machInst, 18, 16);
        uint8_t U = (uint8_t)bits(machInst, 10);
        uint8_t i2 = (uint8_t)bits(machInst, 20, 19);

        if (U) {
            return new SveUdot2wayi<uint16_t, uint16_t, uint32_t>(
                    machInst, zd, zn, zm, i2);
        } else {
            return new SveSdot2wayi<int16_t, int16_t, int32_t>(
                    machInst, zd, zn, zm, i2);
        }
        return new Unknown64(machInst);
    }  // decodeSveScatter32ScaScaledOffset32

    // C4.1.92 SVE Memory - Scatter with Optional Sign Extend
    StaticInstPtr
    decodeSveMemScatterWithOptSignExt(ExtMachInst machInst)
    {
        uint8_t op0 = bits(machInst, 22, 21);
        switch (op0) {
          case 0x0:
            return decodeSveScatter64ScaUnpackUnscaleOffset32(machInst);
          case 0x1:
            if (bits(machInst, 24, 23) != 0x0) {
                return decodeSveScatter64ScaUnpackScaleOffset32(machInst);
            }
            break;
          case 0x2:
            if (bits(machInst, 24, 23) != 0x3) {
                return decodeSveScatter32ScaUnscaleOffset32(machInst);
            }
            break;
          case 0x3:
            return decodeSveScatter32ScaScaledOffset32(machInst);
        }
        return new Unknown64(machInst);
    }  // decodeSveMemScatterWithOptSignExt

    // C4.1.92.5 SVE integer add/subtract vectors (unpredicated)
    StaticInstPtr
    decodeSveIntAddSubVecUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t opc = (uint8_t) bits(machInst, 12, 10);
        uint8_t size = (uint8_t) bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=000
            return decodeSveBinUnpredU<SveAddUnpred>(size, machInst,
                    zd, zn, zm);
          case 0x1:   // opc=001
            return decodeSveBinUnpredU<SveSubUnpred>(size, machInst,
                    zd, zn, zm);
          case 0x2:   // opc=010
            if (size == 0x3) {
                // ADDPT
                return new Unknown64(machInst);
            }
            break;
          case 0x3:   // opc=011
            if (size == 0x3) {
                // SUBPT
                return new Unknown64(machInst);
            }
            break;
          case 0x4:   // opc=100
            return decodeSveBinUnpredS<SveSqadd>(size, machInst, zd, zn, zm);
          case 0x5:   // opc=101
            return decodeSveBinUnpredU<SveUqadd>(size, machInst, zd, zn, zm);
          case 0x6:   // opc=110
            return decodeSveBinUnpredS<SveSqsub>(size, machInst, zd, zn, zm);
          case 0x7:   // opc=111
            return decodeSveBinUnpredU<SveUqsub>(size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntAddSubVecUnpred

    // C4.1.92.6 SVE address generation
    StaticInstPtr
    decodeSveAddrGen(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t mult = 1 << bits(machInst, 11, 10);
        uint8_t opc = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=00
            return new SveAdr<uint64_t>(machInst, zd, zn, zm, mult,
                    SveAdr<uint64_t>::SveAdrOffsetUnpackedSigned);
          case 0x1:   // opc=01
            return new SveAdr<uint64_t>(machInst, zd, zn, zm, mult,
                    SveAdr<uint64_t>::SveAdrOffsetUnpackedUnsigned);
          case 0x2:   // opc=1x
            return new SveAdr<uint32_t>(machInst, zd, zn, zm, mult,
                    SveAdr<uint32_t>::SveAdrOffsetPacked);
          case 0x3:   // opc=1x
            return new SveAdr<uint64_t>(machInst, zd, zn, zm, mult,
                    SveAdr<uint64_t>::SveAdrOffsetPacked);
        }
        return new Unknown64(machInst);
    }  // decodeSveAddrGen

    // C4.1.92.9 SVE integer compare with unsigned immediate
    StaticInstPtr
    decodeSveIntCmpUImm(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t lt_ne = bits(machInst, 13) << 1 | bits(machInst, 4);
        int64_t imm = (int64_t) bits(machInst, 20, 14);
        uint8_t size = bits(machInst, 23, 22);

        switch (lt_ne) {
          case 0:   // lt=0 ne=0
            return decodeSveTerImmPredU<SveCmphsi>(size,
                    machInst, pd, zn, imm, pg);
          case 1:   // lt=0 ne=1
            return decodeSveTerImmPredU<SveCmphii>(size,
                    machInst, pd, zn, imm, pg);
          case 2:   // lt=1 ne=0
            return decodeSveTerImmPredU<SveCmploi>(size,
                    machInst, pd, zn, imm, pg);
          case 3:   // lt=1 ne=1
            return decodeSveTerImmPredU<SveCmplsi>(size,
                    machInst, pd, zn, imm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpUImm

    // C4.1.92.10 SVE predicate logical operations
    StaticInstPtr
    decodeSvePredLogicalOps(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex pn = (RegIndex) (uint8_t) bits(machInst, 8, 5);
        RegIndex pm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 13, 10);
        uint8_t op_s_o2_o3 = (bits(machInst, 23, 22) << 2) |
                             (bits(machInst, 9) << 1) | bits(machInst, 4);

        switch (op_s_o2_o3) {
          case 0x0:   // op=0 S=0 o2=0 o3=0
            return new SvePredAnd<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x1:   // op=0 S=0 o2=0 o3=1
            return new SvePredBic<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x2:   // op=0 S=0 o2=1 o3=0
            return new SvePredEor<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x3:   // op=0 S=0 o2=1 o3=1
            return new SvePredSel<uint8_t>(machInst, pd, pn, pm, pg, true);
          case 0x4:   // op=0 S=1 o2=0 o3=0
            return new SvePredAnds<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x5:   // op=0 S=1 o2=0 o3=1
            return new SvePredBics<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x6:   // op=0 S=1 o2=1 o3=0
            return new SvePredEors<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x8:   // op=1 S=0 o2=0 o3=0
            return new SvePredOrr<uint8_t>(machInst, pd, pn, pm, pg);
          case 0x9:   // op=1 S=0 o2=0 o3=1
            return new SvePredOrn<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xa:   // op=1 S=0 o2=1 o3=0
            return new SvePredNor<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xb:   // op=1 S=0 o2=1 o3=1
            return new SvePredNand<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xc:   // op=1 S=1 o2=0 o3=0
            return new SvePredOrrs<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xd:   // op=1 S=1 o2=0 o3=1
            return new SvePredOrns<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xe:   // op=1 S=1 o2=1 o3=0
            return new SvePredNors<uint8_t>(machInst, pd, pn, pm, pg);
          case 0xf:   // op=1 S=1 o2=1 o3=1
            return new SvePredNands<uint8_t>(machInst, pd, pn, pm, pg);
        }

        return new Unknown64(machInst);
    }  // decodeSvePredLogicalOps

    // C4.1.92.11 SVE integer compare with signed immediate
    StaticInstPtr
    decodeSveIntCmpSImm(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t op_o2_ne = bits(machInst, 15) << 2 |
                           bits(machInst, 13) << 1 | bits(machInst, 4);
        int64_t imm = sext<5>(bits(machInst, 20, 16));
        uint8_t size = bits(machInst, 23, 22);

        switch (op_o2_ne) {
          case 0:   // op=0 o2=0 ne=0
            return decodeSveTerImmPredS<SveCmpgei>(size,
                    machInst, pd, zn, imm, pg);
          case 1:   // op=0 o2=0 ne=1
            return decodeSveTerImmPredS<SveCmpgti>(size,
                    machInst, pd, zn, imm, pg);
          case 2:   // op=0 o2=1 ne=0
            return decodeSveTerImmPredS<SveCmplti>(size,
                    machInst, pd, zn, imm, pg);
          case 3:   // op=0 o2=1 ne=1
            return decodeSveTerImmPredS<SveCmplei>(size,
                    machInst, pd, zn, imm, pg);
          case 4:   // op=1 o2=0 ne=0
            return decodeSveTerImmPredS<SveCmpeqi>(size,
                    machInst, pd, zn, imm, pg);
          case 5:   // op=1 o2=0 ne=1
            return decodeSveTerImmPredS<SveCmpnei>(size,
                    machInst, pd, zn, imm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntCmpSImm

    // C4.1.92.12 SVE broadcast predicate element
    StaticInstPtr
    decodeSveBroadPredElem(ExtMachInst machInst)
    {
        RegIndex Pd = (RegIndex)(uint8_t)bits(machInst, 3, 0);
        RegIndex Pn = (RegIndex)(uint8_t)bits(machInst, 8, 5);
        RegIndex Pg = (RegIndex)(uint8_t)bits(machInst, 13, 10);
        RegIndex Rm = (RegIndex)(0b01100 + (uint8_t)bits(machInst, 17, 16));
        uint8_t imm = (uint8_t)bits(machInst, 20, 18);
        imm += (uint8_t)bits(machInst, 23, 22) << 3;

        const uint8_t size = imm & 0xF;

        if (size == 0) {
            return new Unknown64(machInst);
        }

        if (size & 0b0001) {
            return new SvePsel<uint8_t>(machInst, Pd, Pn, Pg, Rm, imm >> 1);
        } else if (size & 0b0010) {
            return new SvePsel<uint16_t>(machInst, Pd, Pn, Pg, Rm, imm >> 2);
        } else if (size & 0b0100) {
            return new SvePsel<uint32_t>(machInst, Pd, Pn, Pg, Rm, imm >> 3);
        } else if (size & 0b1000) {
            return new SvePsel<uint64_t>(machInst, Pd, Pn, Pg, Rm, imm >> 4);
        }

        return new Unknown64(machInst);
    } // decodeSveBroadPredElem

    // C4.1.92.15 SVE integer clamp
    StaticInstPtr
    decodeSveIntClamp(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex)(uint8_t)bits(machInst, 4, 0);
        RegIndex zn = (RegIndex)(uint8_t)bits(machInst, 9, 5);
        RegIndex zm = (RegIndex)(uint8_t)bits(machInst, 20, 16);
        uint8_t u = bits(machInst, 10);
        unsigned size = bits(machInst, 23, 22);

        switch(u) {
          case 0:   // u=0
            return decodeSveBinUnpredS<SveSclamp>(size, machInst, zd, zn, zm);
          case 1:   // u=1
            return decodeSveBinUnpredU<SveUclamp>(size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSveIntClamp

    // C4.1.92.17 SVE permute vector elements (quadwords)
    StaticInstPtr
    decodeSvePermVecElemQuad(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t opc = (uint8_t)bits(machInst, 12, 10);
        uint8_t size = (uint8_t)bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=000
            return decodeSveBinUnpredU<SveZipq1>(size, machInst, zd, zn, zm);
          case 0x1:   // opc=001
            return decodeSveBinUnpredU<SveZipq2>(size, machInst, zd, zn, zm);
          case 0x2:   // opc=010
            return decodeSveBinUnpredU<SveUzpq1>(size, machInst, zd, zn, zm);
          case 0x3:   // opc=011
            return decodeSveBinUnpredU<SveUzpq2>(size, machInst, zd, zn, zm);
          case 0x6:   // opc=110
            return decodeSveBinUnpredU<SveTblq>(size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSvePermVecElemQuad

    // C4.1.92.18 SVE2 character match
    StaticInstPtr
    decodeSve2CharMatch(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t op = bits(machInst, 4);
        uint8_t size = bits(machInst, 23, 22);

        if (op == 0) {
            if (size == 0) {
                return new SveMatch<uint8_t>(machInst, pd, zn, zm, pg);
            } else if (size == 1) {
                return new SveMatch<uint16_t>(machInst, pd, zn, zm, pg);
            }
        } else {
            if (size == 0) {
                return new SveNmatch<uint8_t>(machInst, pd, zn, zm, pg);
            } else  if (size == 1){
                return new SveNmatch<uint16_t>(machInst, pd, zn, zm, pg);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSve2CharMatch

    // C4.1.92.20 SVE floating-point convert precision odd elements
    StaticInstPtr
    decodeSveFpCvtOdd(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc_opc2 = (bits(machInst, 23, 22) << 2) |
                           bits(machInst, 17, 16);

        switch (opc_opc2) {
          case 0x2: // opc=00 opc2=10
            return new SveFcvtxnt<uint64_t, uint32_t>(
                machInst, zd, zn, pg);
          case 0x8: // opc=10 opc2=00
            return new SveFcvtnt<uint32_t, uint16_t>(
                machInst, zd, zn, pg);
          case 0x9: // opc=10 opc2=01
            return new SveFcvtlt<uint16_t, uint32_t>(
                machInst, zd, zn, pg);
          case 0xa: // opc=10 opc2=10
            return new SveBFcvtNarrowTop<uint32_t, uint16_t>(
                machInst, zd, zn, pg);
          case 0xe: // opc=11 opc2=10
            return new SveFcvtnt<uint64_t, uint32_t>(
                machInst, zd, zn, pg);
          case 0xf: // opc=11 opc2=11
            return new SveFcvtlt<uint32_t, uint64_t>(
                machInst, zd, zn, pg);
        }
        return new Unknown64(machInst);
    } // decodeSveFpCvtOdd

    // C4.1.92.21 SVE2 floating-point pairwise operations
    StaticInstPtr
    decodeSve2FpPairOp(ExtMachInst machInst)
    {
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 18, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0: // opc=000
            return decodeSveBinDestrPredF<SveFaddp>(
                    size, machInst, zdn, zm, pg);
          case 0x4: // opc=100
            return decodeSveBinDestrPredF<SveFmaxnmp>(
                    size, machInst, zdn, zm, pg);
          case 0x5: // opc=101
            return decodeSveBinDestrPredF<SveFminnmp>(
                    size, machInst, zdn, zm, pg);
          case 0x6: // opc=110
            return decodeSveBinDestrPredF<SveFmaxp>(
                    size, machInst, zdn, zm, pg);
          case 0x7: // opc=111
            return decodeSveBinDestrPredF<SveFminp>(
                    size, machInst, zdn, zm, pg);
        }
        return new Unknown64(machInst);
    } // decodeSve2FpPairOp

    // C4.1.92.22 SVE floating-point recursive reduction (quadwords)
    StaticInstPtr
    decodeSveFpRecursiveReducQuad(ExtMachInst machInst)
    {
        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 18, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=000
            return decodeSveUnaryPredF<SveFaddqv>(size, machInst, vd, zn, pg);
          case 0x4:   // opc=100
            return decodeSveUnaryPredF<SveFmaxnmqv>(
                    size, machInst, vd, zn, pg);
          case 0x5:   // opc=101
            return decodeSveUnaryPredF<SveFminnmqv>(
                    size, machInst, vd, zn, pg);
          case 0x6:   // opc=110
            return decodeSveUnaryPredF<SveFmaxqv>(size, machInst, vd, zn, pg);
          case 0x7:   // opc=111
            return decodeSveUnaryPredF<SveFminqv>(size, machInst, vd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpRecursiveReducQuad

    // C4.1.92.23 SVE floating-point multiply-add (indexed)
    StaticInstPtr
    decodeSveFpMulAddIndexed(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        const uint8_t o2_op = bits(machInst, 11, 10);
        uint8_t size = bits(machInst, 23, 22);

        switch (size) {
          case 0x0:
          case 0x1:
            {
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
                uint8_t index = bits(machInst, 20, 19) |
                                (bits(machInst, 22) << 2);
                switch (o2_op) {
                  case 0x0:   // o2=0 op=0
                    return new SveFmlaIdx<uint16_t>(
                        machInst, zd, zn, zm, index);
                  case 0x1:   // o2=0 op=1
                    return new SveFmlsIdx<uint16_t>(
                        machInst, zd, zn, zm, index);
                  case 0x2:   // o2=1 op=0
                    return new SveBfmlaIdx<uint16_t>(
                        machInst, zd, zn, zm, index);
                  case 0x3:   // o2=1 op=1
                    return new SveBfmlsIdx<uint16_t>(
                        machInst, zd, zn, zm, index);
                }
                break;
            }
          case 0x2:
            {
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
                uint8_t index = bits(machInst, 20, 19);
                switch (o2_op) {
                  case 0x0:   // o2=0 op=0
                    return new SveFmlaIdx<uint32_t>(
                        machInst, zd, zn, zm, index);
                  case 0x1:   // o2=0 op=1
                    return new SveFmlsIdx<uint32_t>(
                        machInst, zd, zn, zm, index);
                }
                break;
            }
          case 0x3:
            {
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
                uint8_t index = bits(machInst, 20);
                switch (o2_op) {
                  case 0x0:   // o2=0 op=0
                    return new SveFmlaIdx<uint64_t>(
                        machInst, zd, zn, zm, index);
                  case 0x1:   // o2=0 op=1
                    return new SveFmlsIdx<uint64_t>(
                        machInst, zd, zn, zm, index);
                }
                break;
            }
        }
        return new Unknown64(machInst);
    } // decodeSveFpMulAddIndexed

    // C4.1.92.24 SVE floating-point complex multiply-add (indexed)
    StaticInstPtr
    decodeSveFpCplxMulAddIndexed(ExtMachInst machInst)
    {
        uint8_t size = bits(machInst, 23, 22);
        if (size < 2) {
            return new Unknown64(machInst);
        }

        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t rot = bits(machInst, 11, 10);

        switch (size) {
          case 2:
            {
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
                uint8_t imm = bits(machInst, 20, 19);
                return new SveFcmlai<uint16_t>(
                    machInst, zda, zn, zm, rot, imm);
            }
          case 3:
            {
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
                uint8_t imm = bits(machInst, 20);
                return new SveFcmlai<uint32_t>(
                    machInst, zda, zn, zm, rot, imm);
            }
        }
        return new Unknown64(machInst);
    } // decodeSveFpCplxMulAddIndexed

    // C4.1.92.25 SVE FP clamp
    StaticInstPtr
    decodeSveFpClamp(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t size = bits(machInst, 23, 22);

        if (size == 0x0) {
            return new SveBfclamp<uint16_t>(machInst, zd, zn, zm);
        } else {
            return decodeSveBinUnpredF<SveFclamp>(size, machInst, zd, zn, zm);
        }
        return new Unknown64(machInst);
    } // decodeSveFpClamp

    // C4.1.92.26 SVE floating-point multiply (indexed)
    StaticInstPtr
    decodeSveFpMulIndexed(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        uint8_t o2 = bits(machInst, 11);
        uint8_t size = bits(machInst, 23, 22);

        switch (size) {
          case 0x0:
          case 0x1:
            {
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
                uint8_t index = bits(machInst, 20, 19) |
                                (bits(machInst, 22) << 2);
                if (o2 == 0) {
                    return new SveFmulIdx<uint16_t>(
                        machInst, zd, zn, zm, index);
                } else {
                    return new SveBfmulIdx<uint16_t>(
                        machInst, zd, zn, zm, index);
                }
                break;
            }
          case 0x2:
            {
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 18, 16);
                uint8_t index = bits(machInst, 20, 19);
                if (o2 == 0) {
                    return new SveFmulIdx<uint32_t>(
                        machInst, zd, zn, zm, index);
                }
                break;
            }
          case 0x3:
            {
                RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 19, 16);
                uint8_t index = bits(machInst, 20);
                if (o2 == 0) {
                    return new SveFmulIdx<uint64_t>(
                        machInst, zd, zn, zm, index);
                }
                break;
            }
        }
        return new Unknown64(machInst);
    } // decodeSveFpMulIndexed

    // C4.1.92.28 SVE floating-point matrix multiply accumulate
    StaticInstPtr
    decodeSveFpMatMulAdd(ExtMachInst machInst)
    {
        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (size) {
          case 0x1:
            return new SveBFmmla<uint32_t,uint32_t,uint32_t>(
                machInst, zda, zn, zm);
          case 0x2:
            return new SveFmmlaSp<uint32_t,uint32_t,uint32_t>(
                machInst, zda, zn, zm);
          case 0x3:
            return new SveFmmlaDp<uint64_t,uint64_t,uint64_t>(
                machInst, zda, zn, zm);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpMatMulAdd

    // C4.1.92.29 SVE floating-point recursive reduction
    StaticInstPtr
    decodeSveFpRecursiveReduc(ExtMachInst machInst)
    {
        RegIndex vd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        uint8_t opc = bits(machInst, 18, 16);
        uint8_t size = bits(machInst, 23, 22);

        switch (opc) {
          case 0x0:   // opc=000
            return decodeSveUnaryPredF<SveFaddv>(size, machInst, vd, zn, pg);
          case 0x4:   // opc=100
            return decodeSveUnaryPredF<SveFmaxnmv>(size, machInst, vd, zn, pg);
          case 0x5:   // opc=101
            return decodeSveUnaryPredF<SveFminnmv>(size, machInst, vd, zn, pg);
          case 0x6:   // opc=110
            return decodeSveUnaryPredF<SveFmaxv>(size, machInst, vd, zn, pg);
          case 0x7:   // opc=111
            return decodeSveUnaryPredF<SveFminv>(size, machInst, vd, zn, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpRecursiveReduc

    // C4.1.92.30 SVE floating-point arithmetic (unpredicated)
    StaticInstPtr
    decodeSveFpArithUnpred(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t opc = (uint8_t) bits(machInst, 12, 10);
        uint8_t size = bits(machInst, 23, 22);

        if (size == 0) {
            switch (opc) {
              case 0x0:
                return new SveBfaddUnpred<uint16_t>(machInst, zd, zn, zm);
              case 0x1:
                return new SveBfsubUnpred<uint16_t>(machInst, zd, zn, zm);
              case 0x2:
                return new SveBfmulUnpred<uint16_t>(machInst, zd, zn, zm);
            }
        } else {
            switch (opc) {
              case 0x0:
                return decodeSveBinUnpredF<SveFaddUnpred>(
                        size, machInst, zd, zn, zm);
              case 0x1:
                return decodeSveBinUnpredF<SveFsubUnpred>(
                        size, machInst, zd, zn, zm);
              case 0x2:
                return decodeSveBinUnpredF<SveFmulUnpred>(
                        size, machInst, zd, zn, zm);
              case 0x3:
                return decodeSveBinUnpredF<SveFtsmul>(
                        size, machInst, zd, zn, zm);
              case 0x6:
                return decodeSveBinUnpredF<SveFrecps>(
                        size, machInst, zd, zn, zm);
              case 0x7:
                return decodeSveBinUnpredF<SveFrsqrts>(
                        size, machInst, zd, zn, zm);
            }
        }
        return new Unknown64(machInst);
    }  // decodeSveFpArithUnpred

    // C4.1.92.31 SVE floating-point compare vectors
    StaticInstPtr
    decodeSveFpCmpVec(ExtMachInst machInst)
    {
        RegIndex pd = (RegIndex) (uint8_t) bits(machInst, 3, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);

        uint8_t size = bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }
        uint8_t opc = (bits(machInst, 15) << 2) |
                      (bits(machInst, 13) << 1) |
                      bits(machInst, 4);

        switch (opc) {
          case 0x0:
            return decodeSveCmpF<SveFcmge>(size, machInst, pd, zn, zm, pg);
          case 0x1:
            return decodeSveCmpF<SveFcmgt>(size, machInst, pd, zn, zm, pg);
          case 0x2:
            return decodeSveCmpF<SveFcmeq>(size, machInst, pd, zn, zm, pg);
          case 0x3:
            return decodeSveCmpF<SveFcmne>(size, machInst, pd, zn, zm, pg);
          case 0x4:
            return decodeSveCmpF<SveFcmuo>(size, machInst, pd, zn, zm, pg);
          case 0x5:
            return decodeSveCmpF<SveFacge>(size, machInst, pd, zn, zm, pg);
          case 0x7:
            return decodeSveCmpF<SveFacgt>(size, machInst, pd, zn, zm, pg);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpCmpVec


    // SEL (vectors)
    StaticInstPtr
    decodeSveSelVec(ExtMachInst machInst)
    {
        RegIndex zd = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 13, 10);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t size = bits(machInst, 23, 22);

        return decodeSveBinConstrPredU<SveSel>(size,
            machInst, zd, zn, zm, pg, SvePredType::SELECT);
    }  // decodeSveSelVec

    // FCMLA (vectors)
    StaticInstPtr
    decodeSveFpCplxMulAddVec(ExtMachInst machInst)
    {
        uint8_t size = bits(machInst, 23, 22);
        if (size == 0) {
            return new Unknown64(machInst);
        }

        RegIndex zda = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zn = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 20, 16);
        uint8_t rot = bits(machInst, 14, 13);
        switch (size) {
            case 1:
                return new SveFcmlav<uint16_t>(machInst,
                        zda, zn, zm, pg, rot);
            case 2:
                return new SveFcmlav<uint32_t>(machInst,
                        zda, zn, zm, pg, rot);
            case 3:
                return new SveFcmlav<uint64_t>(machInst,
                        zda, zn, zm, pg, rot);
        }

        return new Unknown64(machInst);
    } // decodeSveFpCplxMulAddVec

    // FCADD
    StaticInstPtr
    decodeSveFpCplxAdd(ExtMachInst machInst)
    {
        uint8_t size = bits(machInst, 23, 22);
        uint8_t rot = bits(machInst, 16) << 1 | 0x01;
        RegIndex zdn = (RegIndex) (uint8_t) bits(machInst, 4, 0);
        RegIndex zm = (RegIndex) (uint8_t) bits(machInst, 9, 5);
        RegIndex pg = (RegIndex) (uint8_t) bits(machInst, 12, 10);
        switch (size) {
            case 1:
                return new SveFcadd<uint16_t>(machInst,
                        zdn, zdn, zm, pg, rot);
            case 2:
                return new SveFcadd<uint32_t>(machInst,
                        zdn, zdn, zm, pg, rot);
            case 3:
                return new SveFcadd<uint64_t>(machInst,
                        zdn, zdn, zm, pg, rot);
        }
        return new Unknown64(machInst);
    }  // decodeSveFpCplxAdd

}  // namespace Aarch64
}};
